[[{cryptography.signature.jwt,use_case.signature,02_doc_has.comparative]]

# OAuth "Zipped" Summary.

* OAuth provides a method for clients (mobile apps, server apps or 
  Javascript apps) to access a protected resource (a file, a bank 
  account, an identity credential, ...) on behalf of a resource owner
  (the citizen owning the the file, bank account, identity, or maybe
  another third party app, ...)
* For Clients to access the protected resource, they must:
  1. obtain an **authorization grant** from the resource owner.
  2. Exchange the authorization grant for an inmutable **access token**.
  3. Use the access token to access the protected resource with 
     the privileges up to those written down in the access token.
     "Use the access token" in practice means that the client 
     attachs the token as a Bearer token in the Authentication HTTP header.

* The inmutable access token contains:
  * the grant's scope authorized by the resource owner.
  * expiration time.
  * other attributes granted by the authorization grant.

* In simple scenarios (machine 2 machine) the client app can presents
  its own credentials to the authorization server to obtain the
  access token without having to first obtain an authorization grant 
  from a resource owner.

* The access token provides an abstraction, replacing different
  authorization constructs (e.g., user/password, assertion, signature, ...)
  for a single token understood by the resource server.<br/>
   This abstraction enables issuing access tokens valid for a short time 
  period, as well as removing the resource server's need to understand a
  wide range of authentication schemes.[[{doc_has.keypoint}]]

  ```
  |           ABSTRACT   PROTOCOL   FLOW
  |┌────────┐                               ┌───────────────┐
  |│        ├──(A)─ Authorization Request¹─>│Resource Owner │
  |│        │<─(B)──── Authorization Grant ─┤(Citizen,SaaS) │
  |│        │                               └───────────────┘
  |│ Client │                               ┌───────────────┐
  |│(Mobile,├──(C)─── Authorization Grant ─>│ Authorization │
  |│ server,│<─(D)─────────── Access Token ─┤ Server (IdP)  │
  |│ JS app)│                               └───────────────┘
  |│        │                               ┌───────────────┐
  |│        ├──(E)─ Access Token ──────────>│ Resource Srv  │
  |│        │<─(F)───── Protected Resource ─┤ (Bank,mail,..)│
  |└────────┘                               └───────────────┘
  | 
  | ¹ In practice, the Authorization Request and Grant is also
  |   "orchestrated" by the Authorization Server since 
  |   clients and Resource Owners don't know/don't trust each
  |   other.
  |    The Authorization Server will include custom security
  |   services and protocols (TLS, 2FA, ...) to identify the
  |   (pre-registered) client and the Resource Owner "Citizen".
  ```

* <https://oauth.net/> [[{PM.TODO}]]
  (source at: <https://github.com/aaronpk/oauth.net>)


[[{PM.TODO.0]]
## Selective Disclosure for JWTs (SD-JWT) 
* REFS:
  * <https://datatracker.ietf.org/doc/draft-ietf-oauth-selective-disclosure-jwt/>
    (Draft 2023-04-11 at the time of writing).
*  The JSON-based representation of claims in a signed JSON Web Token
  (JWT) [RFC7519] is secured against modification using JSON Web
  Signature (JWS) [RFC7515] digital signatures.  A consumer
  checking the signature can safely assume that the contents of the
  token have not been modified.  HOWEVER, ANYONE RECEIVING AN
  UNENCRYPTED JWT CAN READ ALL OF THE CLAIMS AND LIKEWISE,
  ANYONE WITH THE DECRYPTION KEY RECEIVING AN ENCRYPTED JWT CAN ALSO
  READ ALL OF THE CLAIMS.
*  The ability to selectively disclose a subset of JWT claims
  depending on the Verifier becomes crucial to ensure minimum
  disclosure and prevent Verifiers from obtaining claims irrelevant for
  the transaction at hand.

### SD-JWT VC  
* REFS:
  <https://datatracker.ietf.org/doc/draft-ietf-oauth-sd-jwt-vc/>
  (2023-03-12 at the time of writing)
  The type metadata for SD-JWT VC is currently defined in a separate draft,
  available at
  <https://vcstuff.github.io/sd-jwt-vc-types/draft-fett-oauth-sd-jwt-vc-types.html>
  (to be integrated into SD-JWT)
[[PM.TODO.0}]]

[[{protocol.OAuth,use_case.Authorization]]
[[02_doc_has.comparative,cryptography.signature.jwt,02_doc_has.diagram]]
# OAuth Protocol

* <https://tools.ietf.org/html/rfc6749>
* <https://alexbilbie.com/guide-to-oauth-2-grants/>

* OAuth Global Picture. Different applications share the same
  Authentication logic by using a "central" OAuth Provider.
  * Thanks to federation support, such companies can also
    belong to different companies:
    * OAuth Request.`aud`(ience) parameter and others
      (Client Dynamic Registration, JWT signatures, ...) are
      used by the OAuth provider to select identify the originating
      client.
  ```
  | Note: Client in OAuth
  |       ············0) Onboards to OAuth ···················
  |       ·              provider setting up e-amil,         ·
  |       v              e-mail, MFA, biometrics,...         ·
  |  │OAuth   │                                              ·
  |  │Provider│<···········3) Authenticates Against <···     ·
  |    ^  ·                   OAuth Provider obtaining ·     ·
  |    ·  ·                   bearer(session)          ·     ·
  |    ·  ·                   token                          ·
  |    ·  ·                                    │Client App│···
  |    ·  ·                          (Web Brower,Server,Mobile
  |    ·  ·                           App making requests on
  |    ·  ·                           behalf of resource owner)
  |    ·  ·                                            ·
  |    ·  ·                                            ·
  |    ·  ··>2) Setups Trust·> │Service¹│<· 4) Access ··
  |    ·        relationship   │Provider│    services
  |    ·                          ·          from
  |    ·                          ·
  |    ···1) Delegates <·········─┘     ¹ Service Provider can be:
  |          User's Authentication to     - 3rd party REST API (Code Flow Grant)
  |          OAuth provider.              - Native mobile / SPA app with
  |          by registering the app         embedded API.
  |          in the pre-setup             - ...  [[{PM.TODO}]]
  ```

* OAuth Request/Response Summarized Flow:
  ```
  |     ··> (1) Authorization ·> ...  ┐
  |     ·       Request               ·
  | ┌───┴────────────┐         ┌───── v ┐                          ○
  | │Client App or¹ ²│ ·>      │  OAuth │ <·· (2) · user/pass ··> ─┼─
  | │ just User-Agent│         │Provider│         · MFA           / \
  | └─┬── ^ ─────────┘         └──────┬─┘         · ....          Final
  |   ·   ·                           ·                           User
  |   ·   └······(3) Authorization ··─┘                        (Resource
  |   ·              Response ("token")                         Owner)
  |   ·                                                         
  |   └···> ..... ··> (4) HTTP Request  ···> │ Resource │ REST/gRPC/.. API.
  |        └──┬──┘    with access_token      │ Server   │
  |  ┌─······─┘       (access denied if 
  |  ·                 access_token is invalid due to wrong signature,...)
  |  ·                                       
  |  ¹ It can be:             
  |    - a direct path between OAuth Client App and OAuth provider,
  |      as in SPA/Native Apps, or 
  |    - a request to a remote API that finally access the resource.
  |      In that case the token must be safely shared between OAuth Provider
  |      and 3rd party API server in a safe way.
  |      Note: From the OAuth point of view the 3rd party API is the
  |            Client App and the Client App In this diagram is just an
  |            (untrusted) User-Agent, not allowed access.
  | 
  |  ¹ Final registered applications from service providers (Client Apps or
  |     3rd-party Service providers) do NOT store password/biometrics locally.
  |    They just **accept signed proofs of identity or authorization
  |    from the trusted OAuth Authentication Provider ** (JWT token in practice).
  |     The signed proof indicates the effecitve roles for a given user.
  |     Only the Authentication server stores passwords, ...
  |    In such sense, it acts as a "firewall" or "bastion" or identity central
  |    controller for the final service providers.
  ```

* OAuth Request/Response Summarized Flow:
  ```
  ---------------------------------------------------------------
  * (Sec 4.1) Authorization Code Grant:
    Only the 3rd party API is authorized, while the User-Agent
    is not trusted.
    The OAuth response does NOT return the access-token, just 
    a *code* to the untrusted User-Agent. then a second Access
    Token Request/Response is required between
    3rd party App and OAuth Provider to obtain the access-token.
  ---------------------------------------------------------------
  * (Sec 4.2) Implicit Grant:
    Optimized for public clients known to operate a particular redirection URI.
    typically implemented in JS in a browser.
    * access-token is returned directly to the user-agent.
    * No refresh token is returned since 
    * Client must be capable of interacting with user-agent 
      and of receiving incoming requests (via redirection)
      from the authorization server.
    * access_token returned directly in Authorization Response.
    * client authentication is not included relying on the presence
      of the resource owner and the registration of the redirection 
      URI.
    * access token is encoded into the redirection URI, it may be
      exposed to the resource owner and other applications residing 
      on the same device.
  ---------------------------------------------------------------
  * (Sec 4.3) Resource Owner Password Credentials Grant 
    * suitable when resource owner has a trust relationship with
      the client protected by HSM, or highly secured app.
    * Clients must be capable of obtaining the resource owner's
      credentials (username/password,...)
    * Less secure, it must be a last resort when other flows
      are not viable.
    * It follows a direct Client/OAuth Provider Request/Response flow. 
  ---------------------------------------------------------------
  * (Sec 4.4) Client Credentials Grant 
    Simplest grant machine-to-machine Authentication
    An specific user's permission to access data is NOT required.
  ---------------------------------------------------------------
  * (Sec 4.5) Extension Grants
  ---------------------------------------------------------------
  * Refresh token grant.

  ```

## User and App Onboarding to OAuth Providers [[{doc_has.key-point]]

* A normal OAuth provider will decouple next two core functionalities:
  1. **User onboarding**
     * Identifying new users (through biometrics, email/pass, ..)
     * Providing user with some method to identify itself in future logins.
  2. **Application registration**.
  Doing so allows the OAuth provider to link users and group of users to
  different applications with different permissions: 
  * A same user can have different permissions in different applications:<br/>
    User A can be "super user" or Administrator of App A, but just a
    "restricted user" of App B while it has absolutely no access to App C.

* In general, the mapping between onborded users and permission for a given
  app is done through two degrees of indirection.
  1. Application Roles: Each final registered application in the OAuth
     provider will define a set of roles. Each role assigned to a given
     user will allow/deny a set of actions in the final application.
  2. Groups of users: For a given app with many users, roles are assigned
     to groups, and users are registered/unregistered from one or more
     group, just to simplify administration. A group can mentally map to
     a department or category. Then roles are assigned by department and
     users registed/unregistered.
[[doc_has.key-point}]]

* `Authorization Request.Scope`:<br/>
   *  When an app is registered as an OAuth client **to access another
      existing server app** it indicates what (permission) scopes it
      wants access to. Ex: <br/>
      My custom App A wants "read contacts" scope to read
      e-mail contacts from Gmail on behalf of the real user.<br/>
   * In practice, when the user first access the App A, it will be
     redirected to the OAuth Server and will be prompted to allow or
     deny "App A" the "read contacts" scope through a popup like UI.
   * Finally issued access-tokens will be limited (scoped) to the
     to granted -by user- scopes.
   NOTES 
   * No particular scopes ared defined in OAuth spec
     (highly dependent on service's internal Architecture)
   * OAuth Server can further limit the set of scopes (permission)
     granted to App due to global security policies.

## (Sec 4.3) OAuth "RESOURCE OWNER CREDENTIALS" GRANT
  ```
  |                                              ┌──────────────────┐
  |┌──────┐           ┌──────────┐               │OAuth Client      │
  |│OAuth │           │Remote App│               │(REST API/Browser/│
  |│Server│           └────┬─────┘               │ Mobile App)      │
  |└┬─────┘                │                     └────────────────┬─┘
  | │                      │<··························· 1) GET ..┤
  | │                      │   2) signed bearer                   │
  | │                      │·┐    access token                    │
  | │                      │<┘    not found                       │
  | │                      ├ 3) redirect to OAuth2 Server ········>
  | │                      │                                      │
  | │ <······· 4)  GET oauth2/token?client_id=...&client_secret=..┤
  | │                      │                                      │
  | │ "POPUP"                                                     │
  | │ ¿user credentials?  ¿scope/s granted?                       │
  | ├·····························································>
  | │                      │                                      │
  | │<····················································5) POST ┤
  | │ {                                                           │
  | │   grant_type   : "password"          ┐ OAuth data           │
  | │   client_id    : ${APP.clientID}     │ identifying the      │
  | │   client_secret: ${APP.secret}       │ pre-registered       │
  | │   scope        : ${SPACE_SEP_SCOPES} ┘ Application/Service  │
  | │                  (OAuth server can further restrict the set │
  | │                   according to company policies)            │
  | │   username       ${username}         ┐ User's credentials   │
  | │   password       ${password}         ┘                      │
  | │ }                                                           │
  | │       (OAuth server can also require extra MFA/biometric    │
  | │        credentials in addition to the username and pass)    │
  | │·┐ 6) Check user/pass │                                      │
  | │<┘ or/and biometrics  │                                      │
  | │   or/and ...         │                                      │
  | ├· 7) JSON object with with signed tokens ····················>
  | │  {
  | │    token_type   : "Bearer"                                  │
  | │    expires_in   : ...                                       │
  | │    access_token : ...  <·· Attach to App's requests         │
  | │    refresh_token: ...  <·· used to refresh tokens           │
  | │  }                   │                                      │
  |┌────────────┐          ┌──────────┐         ┌─────────────────┴┐
  |│OAuth Server│          │Remote App│         │OAuth Client      │
  |└────────────┘          └──────────┘         │(REST API/Browser/│
  |                                             │ Mobile App)      │
  |                                             └──────────────────┘
  ```

## (sect.4.4) OAuth client credentials grant (M2M)
*
  ```
  | client -> OAuth Server: POST
  |                         (grant_type, client_id, client_secret, scope)
  | OAuth Server -> client: {
  |                           token_type = "bearer"
  |                           expires_in
  |                           access_token (Signed JWT token)
  |                         }
  | client -> Service     : Request Using access_token
  | Service -> Service    : Validate signature in access_token
  ```

## AUTHORIZATION CODE GRANT (3rd party apps access) [[{]]
* (Section 4.1)
* User want's to use a 3rd party app that simultaneously
  access some resource in an existing app.

1. STEP 1: Authenticating user and getting Auth. code
  ```
  | participant "OAuth Server"  as OAS
  | participant "3rd party App" as App3rd
  |
  | participant "Web/Native App" as browser
  |
  | App3rd party registered with OAuthServer obtaining App3rd_client.id
  |
  | browser -> App3rd : req resource
  | App3rd -> browser : NO access_token found in request. Redirect
  | browser -> OAS    : redirect to https://OAuthServer/oauth2/token
  |                    ?response_type=${value_code}
  |                    &client_id=${App3rd_client.id}
  |                    &redirect_uri=${REDITECT_URI} <·· (Optional if pre-registered URI)
  |                    &scope=${SPACE_DELIMITED_SCOPES}
  |                    &state=${OPTIONAL_STATE}
  |                           └──────┬────────┘
  |                           highly recommended to avoid "mixing"
  |                           different browser's session on callback
  | browser <- OAS    : Credentials?
  | browser -> OAS    : "Credentials" proof (user/pass and/or MFA and/or ...)
  | OAS     -> OAS    : validate or abort
  | OAS     -> browser: Redirect to ${REDITECT_URI}
  |                     ?code=${AUTHORIZATION_CODE}
  |                     ?state=${COPY_OF_INPUT_STATE_IN_REQUEST}
  | browser -> App3rd : ${REDITECT_URI}?code=....&state=...
  | App3rd -> App3rd  : check Initial State = Received state
  |                     (Avoid mixing different user sessions)
  |                     Associate code to user's session
  ```

2. STEP 2: Using `code` to get Access Token
  ```
  | App3rd -> OAS: POST
  |                grant_type="authorization_code"
  |                client_id=${App3rd_client.id}
  |                client_secret=...
  |                redirect_uri=${ORIGINAL REDIRECT URI}
  |                code=${CODE}
  | OAS -> App3rd: JSON object
  |                token_type     usually "Bearer"
  |                expires_in     access token TTL(Integer)
  |                access_token   the access token itself
  |                refresh_token  used refresh on expiration
  |                               time
  ```
[[}]]

[[protocol.OAuth}]]

# OpenID Connect [[{protocol.OpenID.connect,use_case.authentication,]]
* OpenID 2 (precedes OpenID Connect):
  * created for FEDERATED ("delegated" to 3rd-party) authentication,
    while don't forcing users to pre-select or negotiate with providers
    to allow them to employ any other account they have.
  * 1+ billions OpenID-enabled accounts on the Internet as of 2016.
  * OIDC2 providers include Google, WordPress, Microsoft, ...

NOTE: Confusingly enough, authorization is also considered some time a
form of pseudo-authentication and OAuth2 is claimed to be an
authentication standard while it is designed as Authorization by design.
(An authorization signed token is a claim that the user is believed
 to be himself for the act of executing an action or accesing 
 some resource).

NOTE: OpenID Connect can also be seen as a "transport" for Credencitials.
In such sense, next alternatives can be cited:
* DIDComm               : <https://identity.foundation/didcomm-messaging/spec/">
* Credential Handler API: <https://w3c-ccg.github.io/credential-handler-api/>
* SAML v2               : <https://saml.xml.org/saml-specifications>
or any other transport envelope. 


Summary from <https://openid.net/specs/openid-connect-core-1_0.html>)

* OpenID Connect improves over OpenID by allowing end-users to log
  in once and access "random" remotes resources with an API "friendly"
  to web and mobile native apps, without the extensions required
  by OpenID. OID-Connect standardizes:
  * scopes:
  * endpoint discovery:
  * dynamic registration of clients:
* OpenID Connect (2014) combines the features of OpenID 2.0, OpenID
  Attribute Exchange 1.0, and OAuth 2.0 in a single protocol, it
  allowing Application clients to obtain End-User identity verifiable
  (signed) Claims using the new IANA registered JWT **ID Token**.

## Nomenclature <!-- { -->

### Main Components/Actors:
* `OpenID Provider (OP)`: OAuth 2.0 Provider implementing the OpenID Connect extensions.
  It issues Identity claims in the ID Token in addition to the standard authorization
  `access_token` in OAuth 2.  (or has control over the real Issuer).<br/>
  End-Users are assigned a locally unique and never reassigned Subject Identifier on it<br/>
  Issuer Identifiers follow the `https://host:port/path?query` scheme.
  It contains the https endpoints (URL protected Resources):
  ```
  * token    endpoint:  <·· standard OAuth endpoints
  * ... (TODO)
  * UserInfo Endpoint:  <·· OpenID Connect Extension. When presented with an
                            standard OAuth 2 access_token by the Client, it
                            returns authorized information about the End-User
                            represented by the corresponding Authorization Grant.
                            content-type := application/json | application/jwt
  ```
* **Self-Issued OpenID Provider: Personal, self-hosted OpenID Provider that issues self-signed ID Tokens.
  In practice, a wallet that signs ID Tokens against a DID or publick key that it can prove to control
  by signing with the private key.<br/>
  **Self-Issued OPs use the special Issuer Identifier `https://self-issued.me`**
* OpenID Client or Relying Party (RP): OAuth 2.0 Client app (native/web or REST API) implementing
  the OpenID Connect extensions. In some Identity texts the Relying Party is the legal actor while
  the OpenID Client is the software component.<br/>
  The OIDC Application Client initiates a new OpenID flow by creating a new OpenID Authorization
  Request (OAuth Request extension). The request is "forwarded" to the User Agent ("Browsers"
  or native apps) and from there to the OP Authorization Endpoint.
* User-Agents: Native app or browser in control of final users to interact with OIDC Providers and
  Relying Parties. In "native" web apps (web applications with the logic "embedded" in Javascript)
  the user-agent is also the OpenID clients, but in many scenarios the Javascript application
  access a remote API, and it is such remote API (server) the one with the role of OpenID Client.
  Such remote API is the one with control of the ID-token, skipping the User-Agent (see Authorization
  Code Grant later on).
* Authentication Context Class: Set of authentication-methods or procedures that are considered to
  be equivalent to each other in a particular context. (for example, military, high, medium, low)

* The summarized sequence diagram to obtain the ID-token from the UserInfo end-point follows:
  ```
  |   --- PRE-SETUP --------------------------------------------------
  |   Relying ¹                       OpenID²
  |   Party                      provider(OP)                       End-User
  |   ┬                                    ┬                         ┬
  |   │                                    │<··· Req. OIDC Account ··┤
  |   │                                    ├─·· alice.myIDOP.org ···>│
  |   ·                                    ·                         ·
  |   │<── OP Admin pre-registers the   ──>│                         ·
  |   │   App with an Application ID,      │  
  |   ·   shared secret, redirect_uri      ·  
  |   ·   callback, ...                    ·
  |   ·                                    ·
  |   --- IDENTITY FLOW ("happy path") -------------------------------
  |   Relying ¹                      OpenID²
  |   Party                     provider(OP)                        End-User
  |   ┬                                    ┬                         ┬
  |   ├─(1) AuthN Request ⁵ ··············>│                         │
  |   │  ex: HTTP 302 response (by Client) ├<(2) Authen.+Authori.···>┤
  |   │  which triggers the User Agent to  │     On error OP informs like ⁶: [[{qa.error_mng}]]
  |   │  make an Auth.Request to OP:       │     HTTP/1.1 400 Bad Request
  |   │  HTTP/1.1 302 Found                │     Content-Type: application/json
  |   │  Location: https://a.b.c/authorize?│     Cache-Control: no-store
  |   │   response_type=code               │     Pragma: no-cache
  |   │   &scope=openid%20profile%20email  │     { "error": "invalid_request" }
  |   │   &client_id=s6BhdRkqt3            │     (Section 4.1.2.1@RFC6749(OAuth 2.0)
  |   │   &state=af0ifjsldkj               │
  |   │   &redirect_uri=https%3A%2F%2Fd.e.f%2Fcb
  |
  | ┌──alt A³: Implicit flow  ──────────────┐ <·· Apps runs in mobile/Web+JS (with an
  | │ │                                   │ │     embedded user-agent).
  | │ │<·(3) ID token+(opt)access_token ·─┤ │
  | │ ├<···············(3) access_token ·─┤ │
  | │ │                                   │ │
  | ├──alt B⁴: Authorization Code flow ─────┤ <·· Front-end runs in mobile/Web, but APIs
  | │ │                                   │ │     runs in backend-servers. The front-end
  | │ ├<···············(3) access_token ──┤ │     has a non-trusted user agent.
  | │ │     HTTP/1.1 302 Found            │ │
  | │ │     Location: https://d.e.f/cb?   │ │
  | │ │       code=SplxlOBeZQQYbYS6WxSbIA │ │
  | │ │       &state=af0ifjsldkj          │ │
  | │ ├─(4)(Opt)UserInfo Req(+acc.Token)─>│ │
  | │ │<·· (5) UserInfo JSON/JWT Resp. ··─┤ │
  | │ │                                   │ │
  | ├──alt C: Hybrid Flow           ────────┤ <·· Custom setups.
  | │ │ ... other Response Types defined  │ │
  | │ │ in OAuth2.0 Multiple Resp.Type    │ │
  | │ │ encoding practices...             │ │
  | └───────────────────────────────────────┘
  |
  |  NOTE: All Token Responses with tokens/secrets info.  [[{security.secret_mng,troubleshooting}]]
  |        MUST include the HTTP response headers:
  |          Cache-Control: no-store
  |          Pragma       : no-cache
  |
  |  ¹⁾ In general Client ID+User-Agent.
  |  ²⁾ In Self Issued OpenID, the OP is a "wallet".
  |  ³ alt A Client is a final native mobile or web app.
  |  ⁴ alt B Client is REST API. User-Agent is not trusted
  |       This degree of indirection avoids sending the
  |       ID-Token directly to the trusted User-Agent.
  |       all tokens are returned from the Token Endpoint,
  |       and they must not be available to the User-agent.
  |       * An Authorization Code is received by the user-agent
  |         that "forwards" to the Client. The client finally
  |         exchanges it for the ID Token.
  |  ⁵ ┌─ Request Params: ────────────────────────────────────────────────────────────────────
  |    │ scope* ····· openid(mandatory),  profile|email|phone
  |    │              If response_type==id_token, profile,email,... must be included 
  |    │              The OP can further filter out some scopes according to established
  |    │              security/organization policies.
  |    │ response* ·· including parameters returned from the endpoints used.
  |    │     _type    The ID-TOken flow used is determined by its value:
  |    │                "response_type"        Flow
  |    │                code ················> Auth. Code Flow
  |    │                id_token ············> Implicit Flow
  |    │                id_token token ······> Implicit Flow
  |    │                value ¹ ·············> Implicit Flow
  |    │                code id_token ·······> Hybrid Flow
  |    │                code token ··········> Hybrid Flow
  |    │                code id_token token ·> Hybrid Flow
  |    │               ¹ Defined in OAuth 2.0, not used in OpenID Connect,
  |    │                 since no ID Token would be returned.
  |    │ client_id* ·· OAuth 2.0 Client Identifier valid at the Authorization Server.
  |    │ redirect_uri* https URI to which the OP response will be sent (if required)
  |    │             matching exactly one pre-registered Redirection URI.
  |    │             (http allowed for confidential ("localhost") Client Type.
  |    │             native apps can use alternative deep-links callback schemes.
  |    │ state* ···· Opaque value to related request and response.
  |    │             Typically, Cross-Site Request Forgery (CSRF, XSRF) mitigation is done  [[{PM.TODO}]]
  |    │             by cryptographically binding  it with a browser cookie.
  |    │ response ·· (OpenID extension), mechanism to be used for returning parameters from the
  |    │  -mode      Authorization Endpoint. Use NOT RECOMMENDED when Response Mode is default
  |    │             one for the Response Type.
  |    │ nonce*  ··· OpenID extension to protect against replay attacks.
  |    │ display ··· Authentication and consent-user interface pages requested to the OP to
  |    │             render to End-User. :=
  |    │             := (full) page* | popup | touch | wap ("feature phone")
  |    │ prompt  ··· case sensitive space separated prompts that the OP shows to End-User. Values:
  |    │             +    none: Display nothing. "login_required", ... is returned if not yet authenticated
  |    │             +   login: prompt End-User for reauthentication.
  |    │             + consent: Prompt End-User for consent 
  |    │             + select_account: Prompt End-User for a user account.(when N are available)
  |    │             prompt can also be used to make sure End-User is still present
  |    │ max_age  ·· Seconds since last time the End-User was actively authenticated.
  |    │ ui_locales  ex. "fr-CA fr en" (in order of preference)
  |    │ id_token ·· ID-Token previously issued. If End-User NOT YET logged in "throw" error
  |    │   _hint     When possible, it SHOULD be present for prompt=none.
  |    │ login_hint  Hint to OP about login identifier the End-User might use to log in
  |    │             For example an e-mail or phone number, ...
  |    │ acr_values  Requested (as a Voluntary Claim) Auth.Context Class Ref.values.
  |    │ claims  ··· "optional" JSON list of Claims.
  │    └──────────────────────────────────────────────────────────────────────────────────────
  |
  | Standard claims returned in JWT ID token(3) or UserInfo response (4) include:
  | │ MEMBER ········ TYPE   ·· DESCRIPTION                                         
  | │ sub  ·········· string ·· Subject Identifier for End-User at the Issuer.      
  | │ name ·········· string ·· End-User's **full** name in displayable form        
  | │                           including all name parts, possibly including titles 
  | │                           and suffixes, ordered according to the End-User's   
  | │                           locale and preferences.                             
  | │ given_name ···· string ·· first name(s) of End-User, white-space separated.   
  | │ family_name ··· string ·· last name(s) of End-User, white-space separated.    
  | │ middle_name ··· string ·· Middle name(s) of End-User white-space separated.   
  | │ nickname  ····· string ·· Casual name of the End-User                         
  | │ preferred ····· string ·· Shorthand name by which the End-User wishes to be   
  | │ _username                 referred to at the RP, such as janedoe or j.doe.    
  | │                           value MAY be any valid JSON string including special
  | │                           characters such as @, /, or whitespace. RP MUST NOT 
  | │                           rely upon this value being unique.                  
  | │ profile ······· string ·· URL of the End-User's profile page.                 
  | │ picture ······· string ·· URL of End-User's profile picture. URL MUST refer   
  | │                           to an (PNG, JPEG, ...) image file, rather than to a 
  | │                            Web page containing an image.                      
  | │ website ······· string ·· URL of the End-User's Web page or blog.             
  | │ email ········· string ·· End-User's preferred e-mail address.                
  | │                           RP MUST NOT rely upon this value being unique.      
  | │ email ········· boolean·· (verified by Auth.Provider)                         
  | │ _verified                                                                     
  | │ gender ········ string ·· := female | male | "other values" MAY be used       
  | │ birthdate ····· string ·· YYYY-MM-DD format. Year MAY be 0000 to omit it.     
  | │                           YYYY       format, avoiding MM-DD                   
  | │ zoneinfo ······ string ·· zoneinfo time zone database. Europe/Paris,...       
  | │ locale ········ string ·· BCP47/RFC5646 language tag, ex: en_US;              
  | │ phone_number ·· string ·· E.164 is the RECOMMENDED format.Ex:                 
  | │                            +1 (425) 555-1212, +56 (2) 687 2400, ...           
  | │ phone_number ·· boolean · (verified by Auth.Provider)                         
  | │  _verified                                                                    
  | │ address ······· JSON obj· preferred postal address. value is a JSON [RFC4627] 
  | │                           structure containing some|all members in Sec.5.1.1. 
  | │ updated_at ···· number ·· JSON secs. since 1970-01-01T0:0:0Z measured in UTC  
  | │ at_hash    ···· string ·· Optional for Auth. Code FLow.                       
  | │                           Access Token hash value. Ex:                        
  | │                           alg==RS256 => SHA-256(access_token)                 
  | │                             => take left-most 128 bits => base64url           
  |
  | JWT ID token(3) in the Implicit Flow contains also:
  | iss*. Case sensitive URL using https-scheme Issuer identifier.
  | sub*. Up to 255 ASCII chars, case-sensitive, Subject Identifier
  | aud*. string[] case sensitive. Audience(s) this ID Token is intended
  |       for. It MUST contain at least the OAuth 2.0 pre-registered  lient_id of
  |       Relying Party.
  | exp*. Expiration Time,  "now"-UTC since 1970-01-01T0:0:0Z secs number
  | iat*. Issued at  Time secs. OIDC clients can reject based on value.
  | auth_time: Time when End-User authentication occurred. REQUIRED when max_age
  |       or auth_time itself is also required.
  | nonce: case-sensitive String value used **to associate a Client session with
  |       ID Token, and to mitigate replay attacks.
  |       Generated by Client in initial Auth. Request, returned "as is".
  |       Client MUST verify that the nonce Claim Value has not changed.
  | acr: Authentication Context Class Reference String satisfied
  |      value "0" => End-User Authentication did not meet requirements of
  |                   ISO/IEC 29115 [ISO29115] level 1. SHOULD NOT be used to
  |                   authorize access to any resource of any monetary value.
  |                   It corresponds to OpenID 2.0 PAPE nist_auth_level 0.
  |      absolute URI or RFC 6711 registered name SHOULD be used as value
  |      Example: "urn:mace:incommon:iap:silver"
  | amr: OPTIONAL. string[] of Authentication Methods References. Values might
  |      indicate that both password and OTP authentication methods were used.
  | azp: OPTIONAL. String|URI OAuth 2.0 Client ID Authorized party
  |      REQUIRED when the ID Token has a single audience and it differs from
  |      Authorized party.
  ```
<!-- } -->
*  Flow comparative
  ```
  |              Hybrid Flow  ··········─┐
  |            Implicit Flow  ······─┐   ·
  |  Authorization Code Flow  ···┐   ·   ·
  |                              ·   ·   ·
  |  Property                    v   v   v
  |  All tokens returned ····· │no │yes│no
  |     from AuthoEndpoint     │   │   │
  |  All tokens returned ····· │yes│no │no
  |      from Token Endpoint   │   │   │
  |  Tokens not revealed  ···· │yes│no │no  [[{doc_has.key-point}]]
  |      to User Agent         │   │   │
  |      (browser)!!!          │   │   │
  |  Client can be ··········· │yes│no │yes
  |      authenticated         │yes│no │yes
  |  Refresh Token possible .. │yes│no │yes
  |  Communication in ········ │no │yes│no
  |     one round trip         │   │   │
  |  Most communication ...... │yes│no │Y/N
  |  server-to-server          │   │   │
  ```
* JWS ID Tokens MUST optionally both JWS signed or JWS signed->JWE encrypted (Nested JWT).
* ID Tokens SHOULD NOT use the JWS or JWE x5u, x5c, jku, or jwk Header Parameter fields.
  Instead, **references to keys used are communicated in advance using Discovery and
  Registration parameters, per Section 10.**
* Unless the Redirection URI is invalid, the Auth.Server returns the
  Client to the Redirection URI specified in the Authorization Request
  with the appropriate error and state parameters. Other parameters
  SHOULD NOT be returned.
* error response parameters are the following:
  ```
  | error*            : Error code ¹
  | error_description : Human-readable
  | error_uri         : web page with additional info.
  | state             : REQUIRED if provided in Auth.Request
  | 
  | ¹ error codes (in addition to errors in OAuth2):
  |   invalid_request_uri        : (in Auth.Request)
  |   invalid_request_object     : 
  |   interaction_required       : OP requires End-User interaction 
  |   login_required             :
  |   account_selection_required :
  |   consent_required           :
  |   request_not_supported      : request      param  not supported by OP.
  |   request_uri_not_supported  : request_uri  param. not supported by OP.
  |   registration_not_supported : registration param. not supported by OP.
  |                                as defined in Section 7.2.1.
  | 
  | Example Authorization Code Flow error response:
  | 
  |   HTTP/1.1 302 Found
  |   Location: https://client.example.org/cb?
  |     error=invalid_request
  |     &error_description=....
  |     &state=1234
  ```

* Authentication Response Validation
  * (Open ID Application) Client makes a Token Request by presenting its Authorization Grant
    (in the form of an Authorization Code) to the Token Endpoint using `grant_type` value
    authorization_code, as described in Section 4.1.3 of OAuth 2.0 [RFC6749].
  * If the Client is a Confidential Client, then it MUST authenticate to the Token Endpoint
    using the authentication method registered for its client_id, as described in Section 9.
  * The Client sends the parameters to the Token Endpoint using the HTTP POST method and
    Form Serialization, per Section 13.2, as described in Section 4.1.3 of OAuth 2.0 [RFC6749].
  * non-normative example of Token Request:
    ```
    | POST /token HTTP/1.1
    | Host: server.example.com
    | Content-Type: application/x-www-form-urlencoded
    | Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW
    |
    | grant_type=authorization_code&code=SplxlOBeZQQYbYS6WxSbIA
    |   &redirect_uri=https%3A%2F%2Fclient.example.org%2Fcb
    ```

* 3.1.3.2. Token Request Validation by Auth.Server (from Client App)
  * Authenticate the Client if it was issued Client Credentials or if
    it uses another Client Authentication method, per Section 9.
  * Ensure the Authorization Code was issued to the authenticated Client.
  * Verify that the Authorization Code is valid.
    If possible, verify that the Authorization Code has not been
    previously used.
  * Ensure that `redirect_uri` value is identical to the original
    value included in the initial Auth.Request. If not present
    the OP MAY return an error or proceed.
  * Verify that the Authorization Code used was issued in response
    to an OpenID Connect Authentication Request.

* non-normative example of successful Token Response:
  ```
  | HTTP/1.1 200 OK
  | Content-Type: application/json
  | Cache-Control: no-store
  | Pragma: no-cache
  |
  | {
  |  "access_token": "SlAV32hkKG",
  |  "token_type": "Bearer",
  |  "refresh_token": "8xLOxBtZp8",
  |  "expires_in": 3600,
  |  "id_token": "eyJhbGciOiJSUzI1NiIsImtpZCI6IjFlOWdkazcifQ.ewogImlzc
  |    yI6ICJodHRwOi8vc2VydmVyLmV4YW1wbGUuY29tIiwKICJzdWIiOiAiMjQ4Mjg5
  |    NzYxMDAxIiwKICJhdWQiOiAiczZCaGRSa3F0MyIsCiAibm9uY2UiOiAibi0wUzZ
  |    fV3pBMk1qIiwKICJleHAiOiAxMzExMjgxOTcwLAogImlhdCI6IDEzMTEyODA5Nz
  |    AKfQ.ggW8hZ1EuVLuxNuuIJKX_V8a_OMXzR0EHR9R6jgdqrOOF4daGU96Sr_P6q
  |    Jp6IcmD3HP99Obi1PRs-cwh3LO-p146waJ8IhehcwL7F09JdijmBqkvPeB2T9CJ
  |    NqeGpe-gccMg4vfKjkM8FcGvnzZUN4_KSP0aAp1tOJ1zZwgjxqGByKHiOtX7Tpd
  |    QyHE5lcMiKPXfEIQILVq0pc_E2DzL7emopWoaoZTF_m0_N0YzFC6g6EJbOEoRoS
  |    K5hoDalrcvRYLSrQAZZKflyuVCyixEoV9GfNQC3_osjzw2PAithfubEEBLuVVk4
  |    XUVrWOLrLl0nx7RkKU8NXNHq-rvKMzqg"
  | }
  ```
* If ID Token is received via direct token endpoint -> TLS -> Client
  TLS server validation MAY be used to validate the issuer in place of
  checking the token signature.

##  Initiating Login from a Third Party
* In some cases, login flow is initiated by an OpenID Provider or another party,
  rather than the Relying Party.
* In this case, the initiator redirects to the RP at its login initiation endpoint,
  which requests that the RP send an Authentication Request to a specified OP.
  (See original spec for further details).

5.1.1.  Address Claim
  ```
  | One of:
  | := formated full address as single string
  | :=  { .. } individual component fields
  | := full address + { ...} individual fields.
  |     formatted: Full maybe-multiline mailing address formatted for display.
  |     street_address: Full street address component (house number and/or street name and/or Post Office Box, ...)
  |     locality: City or locality component.
  |     region: State, province, prefecture, or region component.
  |     postal_code: Zip code or postal code component.
  |     country: Country name component.
  ```

* Additional Claims MAY be used (5.1.2.) using collision-resistant names.

* UserInfo Endpoint SHOULD support the use of Cross Origin Resource Sharing (CORS) and
  or other methods as appropriate to enable Java Script Clients to access the endpoint.

* Scope Values:
  * profile: default profile Claims: name, family_name, given_name,
             middle_name, nickname, preferred_username, profile,
             picture, website, gender, birthdate, zoneinfo, locale, updated_at.
  * email - address - phone
* Claim type by assert origin:
  ```
  | Normal      ¹ asserted by OP.
  | Aggregated  ² asserted by 3rd party Claims Provider,
  |               returned as val. by OP.
  | Distributed ² asserted by 3rd party Claims Provider,
  |               returned as Ref. by OP.
  | * ¹: mandatory, ²: optional
  |
  | Normal Claims MUST be supported.
  | Aggregated&Distributed Claims are OPTIONAL.
  ```

### request vs request_uri Authorization Request parameters:

* request:  OPTIONAL. enable requests to be passed in a self-contained JSON+base64url o JWT (if signed and/or encrypted)
            whose Claims are the request parameters.
* request_uri: OPTIONAL. enables requests to be passed by https reference, rather than by value.
            (particularly useful for large requests encoded in QR, ...).

* non-normative example of the Claims in a Request Object before base64url encoding and signing:
  ```
  | {
  |  "iss": "s6BhdRkqt3",
  |  "aud": "https://server.example.com",
  |  "response_type": "code id_token",
  |  "client_id": "s6BhdRkqt3",
  |  "redirect_uri": "https://client.example.org/cb",
  |  "scope": "openid",
  |  "state": "af0ifjsldkj",
  |  "nonce": "n-0S6_WzA2Mj",
  |  "max_age": 86400,
  |  "claims":
  |   {
  |    "userinfo": {
  |      "given_name": {"essential": true},
  |      "nickname": null,
  |      "email": {"essential": true},
  |      "email_verified": {"essential": true},
  |      "picture": null
  |    },
  |    "id_token": {
  |      "gender": null,
  |      "birthdate": {"essential": true},
  |      "acr": {"values": ["urn:mace:incommon:iap:silver"]}
  |    }
  |   }
  | }
  ```

* Signing it with the RS256 algorithm results in this Request Object
  value (with line wraps within values for display purposes only):

  eyJh...  ~1300 base64enc chars ~
* non-normative example of an Authorization Request using the request parameter
  ```
  https://myOIDC.mycomp.com/authorize?
    response_type=code%20id_token
    &client_id=s6BhdRkqt3
    &redirect_uri=https%3A%2F%2Fclient.example.org%2Fcb
    &scope=openid
    &state=af0ifjsldkj
    &nonce=n-0S6_WzA2Mj
    &request=eyJhbGc... <·· JSON reques base64url encoded
  ```

* non-normative example of an Authorization Request using the request_uri parameter.
  ```
  https://server.example.com/authorize?
    response_type=code%20id_token
    &client_id=s6BhdRkqt3
    &request_uri=https%3A%2F%2Fclient.example.org%2Frequest.jwt%23GkurKxf5T0Y-mnPFCHqWOMiZi4VS138cQO_V7PZHAdM
    &state=af0ifjsldkj&nonce=n-0S6_WzA2Mj
    &scope=openid
  ```

## 7.  Self-Issued OpenID Provider

* Self-Issued OpenID Providers: personal, self-hosted OPs that issue self-signed ID Tokens.
* **Self-Issued OPs use the special Issuer Identifier `https://self-issued.me`**
* messages used to communicate with Self-Issued OPs are mostly the same as standard OPs,
  with a few additional parameters.

### 7.1.  Self-Issued OpenID Provider Discovery

* **dynamic discovery is not performed**. Instead, then the following static configuration values are used:

  ```
  {
   "authorization_endpoint"  : "openid:",
   "issuer"                  : "https://self-issued.me",
   "scopes_supported"        : ["openid", "profile", "email", "address", "phone"],
   "response_types_supported": ["id_token"],
   "subject_types_supported" : ["pairwise"],
   "id_token_signing_alg_values_supported": ["RS256"],
   "request_object_signing_alg_values_supported": ["none", "RS256"]
  }
  ```

* No client registration is required for Self-Issued OP.

* The new optional `registration` Authorization Request parameter enable Clients to provide
  additional registration information to Self-Issued OpenID Providers:
  (information that would normally be provided to an OP during Dynamic Client Registration).
  The value is a JSON object containing Client metadata values, as defined in
  Section 2.1 of the OpenID Connect Dynamic Client Registration 1.0 spec.
  * None of this information is REQUIRED by Self-Issued OPs.
  * Registration parameters typically used would be: `policy_uri`, `tos_uri`, `logo_uri`.
    `redirect_uris` (in case of 2+ Redirection URIs exists) and, for Clients
   requesting encrypted responses, `jwks_uri`, `id_token_encrypted_response_alg` and
   `id_token_encrypted_response_enc`.

* Standard OIDC Provider Request in Self-issued OIDC include:
  * scope:  REQUIRED. with same meaning as in standard OIDC.
  * response_type: REQUIRED. **Constant string value id_token**<br/>
    NOTE that all Claims are returned in the ID Token.
  * client_id: REQUIRED. **Client ID value for the Client, which
    in this case contains the redirect_uri value of the Client.**:<br/>
  * ~redirect_uri~~ not required since it is equal to cient_id.
  * id_token_hint: OPTIONAL. as in standard OIDC.
  * claims: OPTIONAL. as in standard OIDC.
  * registration: OPTIONAL. Self-OIDC extension as explained previously.
  * request: OPTIONAL. as in standard OIDC.
  * Other parameters MAY be sent.

* non-normative example HTTP 302 redirect response by the Client,
  which triggers the User Agent to make an Authentication Request to
  the Self-Issued OpenID Provider (with line wraps within values for display purposes only):

  ```
  HTTP/1.1 302 Found
  Location: openid://?
    response_type=id_token
    &client_id=https%3A%2F%2Fclient.example.org%2Fcb
    &scope=openid%20profile
    &state=af0ifjsldkj
    &nonce=n-0S6_WzA2Mj
    &registration=%7B%22logo_uri%22%3A%22https%3A%2F%2F
      client.example.org%2Flogo.png%22%7D
  ```

### 7.4. Self-Issued OpenID Provider Response

* SSI OP response is equal to normal Implicit Flow response with next refinements:
  * Implicit Flow response => response parameters will be returned in the URL fragment component,
    unless a different Response Mode was specified.
  * `iss=https://self-issued.me`
  * `sub_jwk` required. Public key used to check signature of self-issued ID Token.
     A Claim is present, with value being public key used to check signature of ID Token.
  * `sub=base64url representation of thumbprint of key in the sub_jwk Claim`.
  * No Access Token is returned for accessing a UserInfo Endpoint, so all Claims
    returned MUST be in the ID Token.

* Check 7.5.  for Self-Issued ID Token Validation

## 8 Subject Identifier Types

  ```
  public  : same sub value sued for all Clients.
  pairwise: Provides a different sub value to each Client.
            See section 8.1 in RFC for details.
  ```

## 9.   Methods Client-to-OpenID Provider Authentication

* `client_secret_basic`: Clients receives in presetup a `client_secret`
  from Auth.Server (RFC6749, Section 2.3.1 OAuth 2.0 ) using HTTP Basic
  authentication scheme.
* client_secret_post:  similar to client_secret_basic, including Client
  Credentials in the request body.
* `client_secret_jwt`: Client authenticates in accordance with JWT Profile
  for OAuth 2.0 Client Authentication and Authorization Grants and
  Assertion Framework for OAuth 2.0 Client Authentication and
  Authorization Grants [OAuth.Assertions]. See RFC for details.
* `private_key_jwt`: Clients pre-register pub.key


## See section 10 of RFC for details of Signatures and Encryption

### 10.1.1. Rotation of signing keys
* It can be accomplished with the following approach:
  signer publishes its keys in a JWK Set at its jwks_uri location and includes
  the kid of the signing key in the JOSE Header of each message to indicate
  to the verifier which key is to be used to validate the signature.

### 10.2.1.  Rotating encryption keys necessarily:
* It uses a different process than the one for signing keys because the
  encrypting party starts the process and thus cannot rely on a
  change in kid as a signal that keys need to change.  The encrypting
  party still uses the kid Header Parameter in the JWE to tell the
  decrypting party which private key to use to decrypt, however, the
  party needs to first select the most appropriate key from those
  provided in the JWK Set at the recipient's jwks_uri location.
* To rotate keys, the decrypting party can publish new keys at its
  jwks_uri location and remove from the JWK Set those that are being
  decommissioned. The jwks_uri SHOULD include a Cache-Control header in
  the response that contains a max-age directive, as defined in RFC
  2616 [RFC2616], which enables the encrypting party to safely cache
  the JWK Set and not have to re-retrieve the document for every
  encryption event. The decrypting party SHOULD remove decommissioned
  keys from the JWK Set referenced by jwks_uri but retain them
  internally for some reasonable period of time, coordinated with the
  cache duration, to facilitate a smooth transition between keys by
  allowing the encrypting party some time to obtain the new keys. The
  cache duration SHOULD also be coordinated with the issuance of new
  signing keys, as described in Section 10.1.1.

## Offline Access
  ```
  |  "scope" : "openid ... offline_access"
  |                        └──────┬─────┘
  |requests issuance of Refresh Token allowing to obtain a new
  |Access Token granting access to End-User's UserInfo Endpoint
  |when the End-User is not present/not logged in.
  ```
  See original RFC for more details.

* All OpenID Providers MUST implement the following features defined in this specification.
* Signing ID Tokens with RSA SHA-256
* Preferred Locales
* Authentication Time
* Maximum Authentication Age
* Authentication Context Class Reference

*  Mandatory to Implement Features for Dynamic OpenID Providers
  * id_token Response Type and all that are not Self-Issued OPs MUST also support
    the code and id_token token Response Types.
  * Discovery
  * Dynamic Registration
  * UserInfo Endpoint
  * Public Keys Published as Bare Keys
  * Request URI


* Implementers should be aware that this specification uses several
  IETF specifications that are not yet final specifications, including:
  * JSON Web Token (JWT) draft -25 [JWT]
  * JSON Web Signature (JWS) draft -31 [JWS]
  * JSON Web Encryption (JWE) draft -31 [JWE]
  * JSON Web Key (JWK) draft -31 [JWK]
  * JSON Web Algorithms draft -31 [JWA]
  * Assertion Framework for OAuth 2.0 Client Authentication and Authorization Grants draft -17
  * JSON Web Token (JWT) Profile for OAuth 2.0 Client Authentication and Authorization Grants draft -10

### Related Specs:
* OpenID Connect Discovery 1.0
  Defines how Relying Parties dynamically discover information about OpenID Providers
* OpenID Connect Dynamic Client Registration 1.0
  Defines how Relying Parties dynamically register with OpenID Providers
* OpenID Connect Session Management 1.0
  Defines how to manage OpenID Connect sessions, including logout functionality
* OAuth 2.0 Form Post Response Mode
  Defines how to return OAuth 2.0 Authorization Response parameters
  (including OpenID Connect Authentication Response parameters) using
  HTML form values that are auto-submitted by the User Agent using HTTP
  POST

### Related implementer's guides:
* OpenID Connect Basic Client Implementer's Guide 1.0
* OpenID Connect Implicit Client Implementer's Guide 1.0 [OpenID.Implicit]


## OpenID vs SAML [[{02_doc_has.comparative]]

* Both OpenID vs SAML are different security protocols for single sign-on
  Authorization and Authentication.

* SAML is a oldest standard (2001) with latest update in 2005.
* SAML Auth.Servers ends up returning a SAML signed "response assertions"
  (similar to the JSON response in OAuth) containing statements
  about authorization, authentication and/or attributes (emails, phones,...).

* SAML defines:
  * principal (`client` in OAuth).
  * service provider (application / REST API, like in OAuth)
  * Identity provider: (Active Directory, KeyCloak ...) Server holding
    principal's ids + credentials and registered service providers.
* SAML 2.0 defines also:
  * assertions: Signed claims about a principal
  * protocols : assertion requests and responses
  * bindings  : how requests/responses happen between the service provider
                and identity provider using communication methods like
                HTTP POST
  * profile   : allowed combinations of (assertions, protocols, bindings)
                for various use cases, like SSO.

  ```
                   ┌────────────┬─────────────┬─────────────────┐
                   │ OAuth2     │ OpenId      │ SAML            │
  ┌────────────────┼────────────┼─────────────┼─────────────────┤
  │Token format    │ JSON/SAML2 │ JSON        │ XML             │
  ├────────────────┼────────────┼─────────────┼─────────────────┤
  │Authorization?  │ Yes        │ No          │ Yes             │
  ├────────────────┼────────────┼─────────────┼─────────────────┤
  │Authentication? │ Pseudo     │ Yes         │ Yes             │
  ├────────────────┼────────────┼─────────────┼─────────────────┤
  │created on      │ 2005       │ 2006        │ 2001            │
  ├────────────────┼────────────┼─────────────┼─────────────────┤
  │Current version │ OAuth2     │ OpenID      │ SAML 2.0        │
  │                │            │   Connect   │                 │
  ├────────────────┼────────────┼─────────────┼─────────────────┤
  │Transport       │ HTTP       │ HTTP        │ Transport bind- │
  │                │            │ GET/POST    │ ings exits for: │
  │                │            │             │ SAML SOAP       │
  │                │            │             │ HTTP POST       │
  │                │            │             │ GET Redirect    │
  │                │            │             │ others          │
  ├────────────────┼────────────┼─────────────┼─────────────────┤
  │SECURITY RISKS  │ Phishing   │ Phishing    │ XML Signature   │
  │                │            │             │ wrapping to im- │
  │                │            │             │ personate a user│
  ├────────────────┼────────────┼─────────────┼─────────────────┤
  │Best suited for │ API        │ SSO delega- │ enterprise      │
  │                │   Authori- │ ting to     │ Single sign-on  │
  │                │   zation   │ Google,...  │                 │
  └────────────────┴────────────┴─────────────┴─────────────────┘
  ```
[[02_doc_has.comparative}]]
[[protocol.OpenID.connect}]]


[[{Protocol.OAuth.JAR,cryptography.signature.jwt,cryptography.encryption.jwe]]
# OAuth (JWT)Secured Authorization Request (JAR)
* Part of the OAuth 2.0 Authorization Framework.

* https://datatracker.ietf.org/doc/rfc9101/
* https://www.rfc-editor.org/info/rfc9101.

* C&P from: https://openid.github.io/OpenID4VP/openid-4-verifiable-presentations-wg-draft.html
  * Verifier may send an Authorization Request as Request Object by
     value or by reference as defined in JWT-Secured Authorization Request 

## Context:
* Authorization request in OAuth 2.0 described in RFC 6749 utilizes
  query parameter serialization, which means that authorization request
  parameters are encoded in the URI of the request and sent through
  user agents such as web browsers.  Example: 
  ```
   GET /authorize?
    response_type=code&
    client_id=s6BhdRkqt3&state=xyz&
    &redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb 
    HTTP/1.1
   Host: server.example.com
  ```
   While it is easy to implement, it means that 
  * a) the communication through the user agents is not
       integrity protected and thus, the parameters can be tainted.
  * b) the source of the communication is not authenticated, and 
  * c) communication through the user agents can be monitored.
       Because of these weaknesses, several attacks to the protocol 
       have now been put forward.
    TLS mitigates the communication problem but TLS sessions are
   terminated in the user agent or may be terminated prematurely
   at some middlebox (such as a load balancer).

* JAR introduces the ability to send request parameters in a
  JSON Web Token (JWT) instead, which allows the request to be signed
  with JSON Web Signature (JWS) and encrypted with JSON Web Encryption
  (JWE) 
* new parameters introduced in OAuth 2.0 flows.
  * `request`: JWT whose JWT Claims-Set holds the JSON-encoded 
    OAuth 2.0 authorization request parameters.  
    * Note that, in contrast to RFC 7519 (JWT)", the elements of the
      Claims-Set are encoded OAuth request parameters, supplemented 
      with only a few of the IANA-managed JWT Claims [IANA.JWT.Claims],
      (<https://www.iana.org/assignments/jwt>), in particular:
      "iss" and "aud".
    * JWT is integrity protected and source authenticated using JWS !!!
  * `request_uri`: `request` by (Absolute URI) reference, to reduce
     the size of the transmitted request ("QR" in practice for x-device flows).
     (Section 5.2)

* Request Object MUST contain all the parameters (including extension)
  used to process the OAuth 2.0 Auth.Request except 
   `request` or `request_uri` themself.
  * JSON strings MUST be encoded using UTF-8 [RFC3629].
  * JWT Claims Set is defined in JWT [RFC7519].
    * `iss` and `aud` must be included with `aud` being the Auth.server.
  * JWT Claims Set is then signed or signed 
    resulting in a JWS-signed JWT and optionally encrypted resulting 
    in a Nested JWT.
* The client (3rd party app, SPA app, verifier in OIDC4VP) can inform 
  the authorization server of the algorithms that it supports in its
  dynamic client registration metadata [RFC7591]. [[{PM.TODO}]]
   
* A Request Object (Section 2.1) has the media type [RFC2046]
  `application/oauth-authz-req+jwt` !!!! but some existing
   deployments may be using `application/jwt`.

* Example Request Object Claim:
  ```
  (before base64url [RFC7515] encoding and signing)
  {
   "iss": "s6BhdRkqt3",
   "aud": "https://server.example.com",
   "response_type": "code id_token",
   "client_id": "s6BhdRkqt3",
   "redirect_uri": "https://client.example.org/cb",
   "scope": "openid",
   "state": "af0ifjsldkj",
   "nonce": "n-0S6_WzA2Mj",
   "max_age": 86400
  }
  After RS256 signing base64url encoding:
  ({"alg":"RS256","kid":"k2bdc"})
  eyJhbGciOiJSUzI1NiIsImtpZCI6ImsyYmRjIn0.ewogICAgImlzcyI6ICJzNkJoZF
  JrcXQzIiwKICAgICJhdWQiOiAiaHR0cHM6Ly9zZXJ2ZXIuZXhhbXBsZS5jb20iLAog
  ICAgInJlc3BvbnNlX3R5cGUiOiAiY29kZSBpZF90b2tlbiIsCiAgICAiY2xpZW50X2
  lkIjogInM2QmhkUmtxdDMiLAogICAgInJlZGlyZWN0X3VyaSI6ICJodHRwczovL2Ns
  aWVudC5leGFtcGxlLm9yZy9jYiIsCiAgICAic2NvcGUiOiAib3BlbmlkIiwKICAgIC
  JzdGF0ZSI6ICJhZjBpZmpzbGRraiIsCiAgICAibm9uY2UiOiAibi0wUzZfV3pBMk1q
  IiwKICAgICJtYXhfYWdlIjogODY0MDAKfQ.Nsxa_18VUElVaPjqW_ToI1yrEJ67BgK
  b5xsuZRVqzGkfKrOIX7BCx0biSxYGmjK9KJPctH1OC0iQJwXu5YVY-vnW0_PLJb1C2
  HG-ztVzcnKZC2gE4i0vgQcpkUOCpW3SEYXnyWnKzuKzqSb1wAZALo5f89B_p6QA6j6
  JwBSRvdVsDPdulW8lKxGTbH82czCaQ50rLAg3EYLYaCb4ik4I1zGXE4fvim9FIMs8O
  CMmzwIB5S-ujFfzwFjoyuPEV4hJnoVUmXR_W9typPf846lGwA8h9G9oNTIuX8Ft2jf
  pnZdFmLg3_wr3Wa5q3a-lfbgF3S9H_8nN3j1i7tLR_5Nz-g
  ```

  RSA public key in JWK format that can be used to validate the 
  Request Object signature in this and subsequent Request Object 
  examples:
  ```
  {
   "kty":"RSA",
   "kid":"k2bdc",
   "n":"x5RbkAZkmpRxia65qRQ1wwSMSxQUnS7gcpVTV_cdHmfmG2ltd2yabEO9XadD8
        pJNZubINPpmgHh3J1aD9WRwS05ucmFq3CfFsluLt13_7oX5yDRSKX7poXmT_5
        ko8k4NJZPMAO8fPToDTH7kHYbONSE2FYa5GZ60CUsFhSonI-dcMDJ0Ary9lxI
        w5k2z4TAdARVWcS7sD07VhlMMshrwsPHBQgTatlkxyIHXbYdtak8fqvNAwr7O
        lVEvM_Ipf5OfmdB8Sd-wjzaBsyP4VhJKoi_qdgSzpC694XZeYPq45Sw-q51iF
        UlcOlTCI7z6jltUtnR6ySn6XDGFnzH5Fe5ypw",
   "e":"AQAB"
  }
  ```

* Authorization Request:
  client (App, verifier,...) constructs the Authorization Request
  URI by adding the following parameters to the query component of
  the authorization endpoint URI using the 
  `application/x-www-form-urlencoded` format:
  * `request`
  * `request_uri`
  * `client_id`. It must match that in `request(_uri)`. 

  * client directs the resource owner to the constructed URI using an
    HTTP redirection response or by other means available to it via the
    user agent. !!!! Example:
    ```
    HTTP 302
    Location: /authz?client_id=s6BhdRkqt3&request=eyJhbG..AlMGzw HTTP/1.1
    Host: a.b.com


    HTTP 302
    Location: /authz?client_id=s6BhdRkqt3&
                    request_uri=https%3A%2F%2Fa.b.com%2Frequest.jwt%2FGkur... HTTP/1.1
    Host: server.example.com

    ```
  * client MAY send the parameters included in the Request Object
    duplicated in the query parameters for backward compatibility,
    but Auth. Server must ignore them. 

* Signature Algorithm verification MUST be performed by recipients
  (Auth. SERvers or SIOP Wallets) as specified in Sections 3.1 and 3.2 of [RFC8725].
  * On failure, they must respond with `invalid_request_object` 

* Authorization Server Response (Wallet in SIOP)
  * All those in Section 4 of [RFC6749] (OAuth 2.0).
  * invalid_request_uri
  * invalid_request_object
  * request_not_supported
  * request_uri_not_supported

* Client implementations supporting the Request Object URI method MUST
  support TLS.
* HTTP clients MUST also verify the TLS server certificate, using DNS-
  ID [RFC6125], to avoid man-in-the-middle attacks. 
*  Support for DNS-ID identifier type (that is, the dNSName identity
   in the subjectAltName extension) is REQUIRED. 

##  IANA Considerations
* Since the Request Object is a JWT, the core JWT claims cannot be used
  for any purpose in the Request Object other than for what JWT
  dictates. Thus, they have been registered as OAuth authorization
  request parameters to avoid future OAuth extensions using them with
  different meanings.
* OAuth Authorization Server Metadata Registry
  * Spec add new "require_signed_request_object"
    indicating where authorization request needs to
    be protected as Request Object and provided through 
    either "request" or "request_uri parameter".
* OAuth Dynamic Client Registration Metadata Registry
  * Specs add new  "require_signed_request_object" 
    indicating where authorization request needs to
    be protected as Request Object and provided 
    through either "request" or "request_uri parameter".

* See original source, section 10 for Security Considerations.
* See original source, section 11 for Privacy Considerations
[[Protocol.OAuth.JAR}]]

# OAuth (JWT)Secured Authorization Response Mode  (JARM) [[{Protocol.OAuth.JARM]]
* REF: <https://openid.net/specs/oauth-v2-jarm.html>

* JWT-based mode to encode OAuth authorization responses
  enhancing the security with support for signing and optional
  encryption.
* JWT always contains:
  * `iss`: issuer 
  * `aud`: OAuth client_id this response is intended for.
  * `exp`: expiration of the JWT. (10 min max is RECOMMENDED).
  * authorization endpoint response parameters as defined for
    the particular response types.
    * For example Response for grant type authorization "code" 
      requires the extra `code` and `state` claims.
  * Error response params if appropiate:
    error (code), error_description and  error_uri. 
* Signing + encrypting results in a nested JWT.

* Response Modes:
  * Response Mode "query.jwt" example:
    ```
    HTTP/1.1 302 Found
    Location: https://client.example.com/cb?response=eyJra... JWT token ...
    ```
    * WARN: "query.jwt" response mode MUST NOT be used in conjunction 
      with response types that contain "token" or "id_token" unless
      the response JWT is encrypted to prevent token leakage in the URL.
  * Response Mode "query.jwt" example:
    ```
    HTTP/1.1 302 Found
    Location: https://client.example.com/cb#response=eyJra... JWT token ...
    ```
  * Response Mode "form_post.jwt" example:
    ```
    | HTTP/1.1 200 OK
    | Content-Type: text/html;charset=UTF-8
    | Cache-Control: no-cache, no-store
    | Pragma: no-cache
    | 
    | <html>
    |  <head><title>Submit This Form</title></head>
    |  <body onload="javascript:document.forms[0].submit()">
    |   <form method="post" action="https://client.example.com/cb">
    |     <input type="hidden" name="response"
    |      value="eyJraW ... JWT token ... " />
    |     </form>
    |    </body>
    |   </html>
    | <!-- form auto-submitted in the User Agent in
    |      "application/x-www-form-urlencoded" format like:
    |      POST /cb HTTP/1.1
    |      Host: client.example.org
    |      Content-Type: application/x-www-form-urlencoded
    |      
    |      response=eyJraW JWT Token ...
    ```

* Response Mode "jwt" defaults to redirect default encoding:
  query.jwt for `code` and fragment.jwt for `token` and response types
  defined in "OAuth 2.0 Multiple Response Type Encoding Practices""
  
## Processing rules
* client decrypts the JWT using the default key for the respective issuer or,
  if applicable, determined by the kid JWT header parameter. 
* The key might be a private key, where the corresponding public key is
  registered with the expected issuer of the response.
* check iss: well known, identifies the expected issuer.
* check aud matches client id
* checks exp 
* check signature. 
* check CSRF detection ... (out of scope of this specification).
* The following client metadata parameters in the Dynamic Client
  Registration Protocol are introduced by this specification:
  * `authorization_signed_response_alg`: REQUIRED
  * `authorization_encrypted_response_alg`: REQUIRED
  * `authorization_encrypted_response_enc`: REQUIRED
  NOTE: `jwks_uri` or `jwks metadata` parameters can be used by
     clients to register their public encryption keys.

* Authorization Server Metadata:
  (Check original doc for more info) 
  new params are included:
  * `authorization_signing_alg_values_supported`    OPTIONAL
  * `authorization_encryption_alg_values_supported` OPTIONAL
  * `authorization_encryption_enc_values_supported` OPTIONAL

* See original doc for details on Security Considerations
[[Protocol.OAuth.JARM}]]

# FAPI Related Tecnologies [[{FAPI,PM.TODO]]
<https://medium.com/@hidebike712/fapi2-explained-8602e52596e5>
[[FAPI}]]

# TODO/Non-Classified [[{PM.TODO.now]]
* OAuth 2.0 Bearer Token Usage [RFC6750]
* <https://openid.net/specs/openid-connect-core-1_0.html> @ma
* OpenID Connect Discovery 1.0 [OpenID.Discovery]
* OpenID Connect Dynamic Client Registration 1.0
  <https://openid.net/specs/openid-connect-registration-1_0.html>
* Dynamic Client Registration Protocol [RFC7591] defines an API  
  for dynamically registering OAuth 2.0 client metadata with
  authorization servers. [[{PM.TODO.now}]]

* https://openid.net/sg/openid4vc/specifications/
* https://openid.github.io/OpenID4VCI/openid-4-verifiable-credential-issuance-wg-draft.html
* https://openid.github.io/OpenID4VP/

* OAuth 2.0 Threat Model and Security Considerations
  <https://tools.ietf.org/html/rfc6819>

OThers:
* @[https://oauth.net/2/]
[[}]]
