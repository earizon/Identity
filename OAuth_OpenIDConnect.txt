[[{cryptography.signature.jwt,use_case.signature,02_doc_has.comparative]]

# OAuth "Zipped" Summary.

* OAuth provides a method for clients (mobile apps, server apps or 
  Javascript apps) to access a protected resource (a file, a bank 
  account, an identity credential, ...) on behalf of a resource owner
  (the citizen owning the the file, bank account, identity, or maybe
  another third party app, ...)
* For Clients to access the protected resource, they must:
  1. obtain an **authorization grant** from the resource owner.
  2. Exchange the authorization grant for an inmutable **access token**.
  3. Use the access token to access the protected resource with 
     the privileges up to those written down in the access token.
     "Use the access token" in practice means that the client 
     attachs the token as a Bearer token in the Authentication HTTP header.

* The inmutable access token contains:
  * the grant's scope authorized by the resource owner.
  * expiration time.
  * other attributes granted by the authorization grant.

* In simple scenarios (machine 2 machine) the client app can presents
  its own credentials to the authorization server to obtain the
  access token without having to first obtain an authorization grant 
  from a resource owner.

* The access token provides an abstraction, replacing different
  authorization constructs (e.g., user/password, assertion, signature, ...)
  for a single token understood by the resource server.<br/>
   This abstraction enables issuing access tokens valid for a short time 
  period, as well as removing the resource server's need to understand a
  wide range of authentication schemes.[[{doc_has.keypoint}]]

  ```
  |           ABSTRACT   PROTOCOL   FLOW
  |┌────────┐                               ┌───────────────┐
  |│        ├──(A)─ Authorization Request¹─>│Resource Owner │
  |│        │<─(B)──── Authorization Grant ─┤(Citizen,SaaS) │
  |│        │                               └───────────────┘
  |│ Client │                               ┌───────────────┐
  |│(Mobile,├──(C)─── Authorization Grant ─>│ Authorization │
  |│ server,│<─(D)─────────── Access Token ─┤ Server (IdP)  │
  |│ JS app)│                               └───────────────┘
  |│        │                               ┌───────────────┐
  |│        ├──(E)─ Access Token ──────────>│ Resource Srv  │
  |│        │<─(F)───── Protected Resource ─┤ (Bank,mail,..)│
  |└────────┘                               └───────────────┘
  | 
  | ¹ In practice, the Authorization Request and Grant is also
  |   "orchestrated" by the Authorization Server since 
  |   clients and Resource Owners don't know/don't trust each
  |   other.
  |    The Authorization Server will include custom security
  |   services and protocols (TLS, 2FA, ...) to identify the
  |   (pre-registered) client and the Resource Owner "Citizen".
  ```

* <https://oauth.net/> [[{PM.TODO}]]
  (source at: <https://github.com/aaronpk/oauth.net>)

## JWS (RFC 7515) <!-- { -->
* REF: <https://tools.ietf.org/html/rfc7515>

* JSON Web Signature (JWS) represents content secured with digital
  signatures or Message Authentication Codes (MACs) using JSON-based
  data structures.<br/>
   Related cryptographic algorithms and identifiers are described
  in the JSON Web Algorithms (JWA) spec. 
* JWT (JWS) structure:
  ```
  | xxxxx.yyyyyyyyyyyyyyyyyyy.zzzzz ← Base64URL encoded
  | ^     ^                   ^     ↖
  | │  ┌──┘                   │      ☞ format more compact when compared to
  | │  │  ┌───────────────────┘        XML-based standards such as SAML.
  | │  │  │
  | │  │  SIGNATURE
  | │  │             └ (with shared_secret or priv.key)
  | │  │               (Using signature algorithm of HEADER)
  | │  PAYLOAD
  | │  - claims about an entity + additional data.
  | │
  | │  - types of claims
  | │    - registered : non mandatory but recommended for interoperability:
  | │      (mandatory 
  | │       "jti" (JWT ID) Claim
  | │       "iss" (issuer)
  | │       "exp" (expiration time)
  | │       "iat" (Issued At)
  | │       "sub" (subject)
  | │       "aud" (aud)ience of the token, i.e., the "web app" that is meant to
  | │             be the final recipient of the token. eg.: In the case of an
  | │             ID token, its value is the client ID of the application that
  | │             should consume the token.
  | │       "nbf" (Not Before)
  | │
  | │
  | │    - public     : Defined at will. To avoid collisions they should be defined
  | │                   in the IANA JSON Web Token Registry or be defined as a URI
  | │                   that contains a collision resistant namespace.
  | │
  | │    - private    : custom claims between parties
  | │
  | HEADER typically consists of:
  | {
  |   "alg": "HS256", ← signing algorithm used (HMAC SHA256, RSA, ECDSA...)
  |   "typ": "JWT"    ← type of tokern (JWT)
  | }
  ```

* A common JWT ussage pattern involves client sending the JWT in the
  HTTP Authorization header using the Bearer-schema:
  ```
  Authorization: Bearer <token>
  ( Stateless authorization )
  ```

* KEY-POINT: By sending in the Authorization header, Cross-Origin Resource Sharing
  (CORS) won't be an issue as it doesn't use cookies.

[[{02_doc_has.comparative]]
* Signing XML with XML Digital Signature is very complex and
  error prone when compared to the simplicity of signing JSON.
[[}]]
<!-- } -->


# JWT (RFC 7519) <!-- { -->
* <https://tools.ietf.org/html/rfc7519> 
* specification for compact, **URL-SAFE** means of REPRESENTING
  CLAIMS TO BE TRANSFERRED BETWEEN TWO PARTIES, commonly used 
  to representing OAuth 2.0 authentication tokens ("access_token")
  and OpenID Connect Identity tokens ("id_token").<br/>


* In practice: A JWT is a JWS structure with a JSON object as the payload.
  and some optional predefined claims (JSON keys) such as iss, aud, exp, ...
* claims are encoded as a JSON object used as:
  * the payload of a JSON Web Signature (JWS) structure
    enabling the claims to be digitally signed using either:
    * symetric shared secrets (HMAC)
    * asymetrict key pairs RSA/ECDSA.
  * the plaintext of a JSON Web Encryption (JWE) structure.
    enabling the claims to be integrity protected with a
    Message Authentication Code (MAC) and/or encrypted.

## JWT Best Patterns [[{qa.101]]
* <https://www.ietf.org/rfc/rfc8725.html>
* Best patterns for JWT (and underlying JWS, jWE and JWA).
  (considered "floor", not "ceiling").
* Perform Algorithm Verification. Library MUST ensure that
  "alg" and/or "enc" headers specifies the same algorithm used
  for the cryptographic operation. 
* EACH KEY MUST BE USED WITH EXACTLY ONE ALGORITHM:
  and this MUST be checked when the cryptographic operation 
  is performed.
* Use and Validate Audience:
* Issuers issuing JWT for different applications/relying
  parties, must include the "aud" (audience) claim and
  applications/relying parties validating the incomming
  JWT MUST validate such audience value.
* Do Not Trust Received Claims:
  * Ensure that the "kid" (key ID) header is used only
    to perform key lookup. In particular ensure that it 
    does NOT create SQL or LDAP injection vulnerabilities
    by validating and/or sanitizing the received value.
  * Similarly, blindly following a "jku" (JWK set URL) or
    "x5u" (X.509 URL) header, which may contain an arbitrary
    URL, could result in server-side request forgery (SSRF)
    attacks. A pre-configured "allowed URL list" must be used.
* Use Explicit Typing for JWT instances. For instance, 
  Security Event Tokens (RFC8417) will use 
  "application/secevent+jwt" for the media type and
  "secevent+jwt" for the for the "typ" value.
* Use Mutually Exclusive Validation Rules for Different Kinds of JWTs
  (required and optional claims)
* To prevent substitution of JWTs from one context into another,
  application developers may employ a number of strategies:
  * Use explicit typing for different kinds of JWTs.
  * Use different sets of required claims or different required
    claim values. 
  * Use different sets of required Header Parameters or different
    required Header Parameter values.
  * Use different keys for different kinds of JWTs.
  * Use different "aud" values for different uses of JWTs.
  * Use different issuers for different kinds of JWTs.

### OAuth/OpenID-Connect related JWT Best-Patterns
* OpenID-Connect compliant web-apps will go through the
  `/oauth/authorize` endpoint using the authorization code flow.
* Secret information use JWE.
* Do not store JWT inside localStorage or session storage in
  web browsers ("user-agents" using OAuth nomenclature) since 
  it's accessible by any script (XSS attack/compromised page).
  Preffer `httpOnly` cookies stores: Cookies only sent in
  HTTP requests back to the server and never accessible to JS.
* Don't use JWT as Sessions since it's error prone.
* In the context of OAuth (see next), the JWT is ussually 
  encode as ¹: [[{doc_has.key_point}]]
  * query URI parameter (params after '?'). Example:
    ```
    | https://...?access_token=${JWT_ACCESS_TOKEN}
                  └──────────┴─ JWT token type
    ```
  * fragment component. Example:
    ```
    | https://...#access_token=${JWT}
                  └──────────┴─ JWT token type
    ```
  * form post. Example:
    ```
    | POST /resource HTTP/1.1
    | Host: server.example.com
    | Content-Type: application/x-www-form-urlencoded
    |
    | access_token=${JWT_ACCESS_TOKEN}
    ```
  * Bearer token in authorization Header
    (just for the broadly used JWT access_token vs any other
     JWT representing claims, ...)
    ```
    | Authorization: Bearer ${JWT_ACCESS_TOKEN}
  ¹ Remember: JWT has been designed to be URL-safe 
    ```
[[qa.101}]]

## Command line JWT "juggling":

* REF: <https://github.com/tldr-pages/tldr/blob/master/pages/common/jwt.md>
  ```
  | $ jwt decode {{jwt_string}}       ←  Decode a JWT.
  |                                      -j to decode as JSON string
  |
  | $ jwt encode --alg {{HS256}} \   ← Encode a JSON string → JWT
  |  --secret {{1234567890}}     \
  |  '{{json_string}}'
  |
  | $ jwt encode --alg {{HS256}} \   ← Encode key pair payload to JWT
  |   --secret {{1234567890}}    \
  |  -P key=value
  ```

## JSON Web Encryption (JWE RFC 7516) <!-- { -->
* REF: <https://tools.ietf.org/html/rfc7516>
* Spec for JSON objects representin encrypted content.
  Related digital signature and Message Authentication Code (MAC)
  capabilities are described in the separate JSON Web Signature(JWS)
  specification.
* In addition to JWS Header.Payload.Signature format, we have a
  5 fileds `Header.Key.Vector.Payload.Tag`, defined in "7.1. JWE Compact Serialization"
  in RFC 7516, JSON Web Encryption (JWE).
  ```
  BASE64URL(UTF8(JWE Protected Header)) || '.' ||
  BASE64URL(JWE Encrypted Key)          || '.' || ¹
  BASE64URL(JWE Initialization Vector)  || '.' ||
  BASE64URL(JWE Ciphertext)             || '.' || ²
  BASE64URL(JWE Authentication Tag)
  ```
  Used to encrypt (ID and others) tokens.

  ¹ In general encryption is two step process:
    STEP 1) Encrypt data using a shared symmetric key.
    STEP 2) Encrypt symmetric key using a public (asymmetric) key.

  ² JWE RFC 7516 says that any data can be used as the input.
    However, in the context of ID Token, the data has to be a JWS.
    That is, a JWS is nested in a JWE.

* Example JWE:
  ```
  | eyJhbGciOiJSU0EtT0FFUCIsImVuYyI6IkEyNTZHQ00ifQ.                    <·· {"alg":"RSA-OAEP","enc":"A256GCM"}
  | OKOawDo13gRp2ojaHV7LFpZcgV7T6DVZKTyKOMTYUmKoTCVJRgckCL9kiMT03JGe   <·· Binary Encrypted Key
  | ipsEdY3mx_etLbbWSrFr05kLzcSr4qKAq7YN7e9jwQRb23nfa6c9d-StnImGyFDb   
  | Sv04uVuxIp5Zms1gNxKKK2Da14B8S4rzVRltdYwam_lDp5XnZAYpQdb76FdIKLaV
  | mqgfwX7XWRxv2322i-vDxRfqNzo_tETKzpVLzfiwQyeyPGLBIO56YJ7eObdv0je8
  | 1860ppamavo35UgoRdbYaBcoh9QcfylQr66oc6vFWXRcZ_ZT2LawVCWTIy3brGPi
  | 6UklfCpIMfIjf7iGdXKHzg.
  | 48V1_ALb6US04U3b.                                                  <·· Binary IV
  | 5eym8TW_c8SuK0ltJ3rpYIzOeDQz7TALvtu6UG9oMo4vpzs9tX_EFShS8iB7j6ji   <·· Binary Chipertext
  | SdiwkIr3ajwQzaBtQD_A.                                        
  | XFBoMYUZodetZdvTiFvSkQ                                             <·· Binary JWE Authentication Tag
  ```
<!-- } -->

## JSON Web Key (JWK)
* REF: <https://tools.ietf.org/html/rfc7517>
* Spec for a JSON data structure representing a cryptographic key
  It defines also a JWK-Set JSON for set of JWKs.

## JSON Web Algorithms (JWA)
* REF: <https://tools.ietf.org/html/rfc7518>
* This specification registers cryptographic algorithms and identifiers
  to be used with the JSON Web Signature (JWS), JSON Web Encryption
  (JWE), and JSON Web Key (JWK) specifications.  It defines several
  IANA registries for these identifiers. [[}]]

## JOSE: (J)SON (O)bject (S)igning and (E)ncryption [[{]]
* `JOSE "==" JWS + JWE + JWK + JWA`

* Following is a decoded JSON payload representing an example
 of JOSE protected header parameters as defined by the JWS JSON
 Serialization syntax.
 ```
 {
   "name": "identityKey",← extension 1
   "alg" : "ES256K",     ← ECDSA using secp256k1 curve + SHA-256
   "typ" : "JOSE+JSON",  ← media type of complete JWS
   "b64" : false,        ← extension 2
                           true ⇒ payload=ASCII(BASE64URL(JWS Payload))
   "crit": ["b64"],      ← Critical extensions that must be accepted
   "jwk" :  {            ← pub.key used to sign JOSE header+JWS payload.
     "kty": "EC",          represented as JSON Web Key
     "use": "sig",       ← Intended user
     "crv": "secp256k1",
     "x"  : "0",         ← X-coordinate of corresponding pub key.
     "y"  : "0",         ← Y-coordinate of the corresponding pub key.
   },
 }
 ```

### JOSE Implementations:
* REF: @[https://www.npmjs.com/package/node-jose]
* JS implementation of the JSON Object Signing and Encryption (JOSE)
  for current web browsers and node.js-based servers. This library implements
  (wherever possible) all algorithms, formats, and options in JWS, JWE, JWK, and
  JWA and uses native cryptographic support (WebCrypto API or node.js' "crypto"
  module) where feasible.<br/>
  Ex ussage:
  ```
  // Create Self Signed JSON token
  const  privKey01 = jose.JWK.asKey(
      "-----BEGIN PRIVATE KEY-----\n" +
      ...
      "-----END RSA PRIVATE KEY-----");
  const payload = { iss:"service1", aud:"service2" };
  const  JWT01 = jose.JWT.sign (payload, privKey01 , { expiresIn: "1 hours" });
  ```
[[}]]

[[{PM.TODO.0]]
## Selective Disclosure for JWTs (SD-JWT) 
* REFS:
  * <https://datatracker.ietf.org/doc/draft-ietf-oauth-selective-disclosure-jwt/>
    (Draft 2023-04-11 at the time of writing).
*  The JSON-based representation of claims in a signed JSON Web Token
  (JWT) [RFC7519] is secured against modification using JSON Web
  Signature (JWS) [RFC7515] digital signatures.  A consumer
  checking the signature can safely assume that the contents of the
  token have not been modified.  HOWEVER, ANYONE RECEIVING AN
  UNENCRYPTED JWT CAN READ ALL OF THE CLAIMS AND LIKEWISE,
  ANYONE WITH THE DECRYPTION KEY RECEIVING AN ENCRYPTED JWT CAN ALSO
  READ ALL OF THE CLAIMS.
*  The ability to selectively disclose a subset of JWT claims
  depending on the Verifier becomes crucial to ensure minimum
  disclosure and prevent Verifiers from obtaining claims irrelevant for
  the transaction at hand.

### SD-JWT VC  
* REFS:
  <https://datatracker.ietf.org/doc/draft-ietf-oauth-sd-jwt-vc/>
  (2023-03-12 at the time of writing)
  The type metadata for SD-JWT VC is currently defined in a separate draft,
  available at
  <https://vcstuff.github.io/sd-jwt-vc-types/draft-fett-oauth-sd-jwt-vc-types.html>
  (to be integrated into SD-JWT)
[[PM.TODO.0}]]

[[{protocol.OAuth,use_case.Authorization]]
[[02_doc_has.comparative,cryptography.signature.jwt,02_doc_has.diagram]]
# OAuth Protocol

* <https://tools.ietf.org/html/rfc6749>
* <https://alexbilbie.com/guide-to-oauth-2-grants/>

* OAuth Global Picture. Different applications share the same
  Authentication logic by using a "central" OAuth Provider.
  * Thanks to federation support, such companies can also
    belong to different companies:
    * OAuth Request.`aud`(ience) parameter and others
      (Client Dynamic Registration, JWT signatures, ...) are
      used by the OAuth provider to select identify the originating
      client.
  ```
  | Note: Client in OAuth
  |       ············0) Onboards to OAuth ···················
  |       ·              provider setting up e-amil,         ·
  |       v              e-mail, MFA, biometrics,...         ·
  |  │OAuth   │                                              ·
  |  │Provider│<···········3) Authenticates Against <···     ·
  |    ^  ·                   OAuth Provider obtaining ·     ·
  |    ·  ·                   bearer(session)          ·     ·
  |    ·  ·                   token                          ·
  |    ·  ·                                    │Client App│···
  |    ·  ·                          (Web Brower,Server,Mobile
  |    ·  ·                           App making requests on
  |    ·  ·                           behalf of resource owner)
  |    ·  ·                                            ·
  |    ·  ·                                            ·
  |    ·  ··>2) Setups Trust·> │Service¹│<· 4) Access ··
  |    ·        relationship   │Provider│    services
  |    ·                          ·          from
  |    ·                          ·
  |    ···1) Delegates <·········─┘     ¹ Service Provider can be:
  |          User's Authentication to     - 3rd party REST API (Code Flow Grant)
  |          OAuth provider.              - Native mobile / SPA app with
  |          by registering the app         embedded API.
  |          in the pre-setup             - ...  [[{PM.TODO}]]
  ```

* OAuth Request/Response Summarized Flow:
  ```
  |     ··> (1) Authorization ·> ...  ┐
  |     ·       Request               ·
  | ┌───┴────────────┐         ┌───── v ┐                          ○
  | │Client App or¹ ²│ ·>      │  OAuth │ <·· (2) · user/pass ··> ─┼─
  | │ just User-Agent│         │Provider│         · MFA           / \
  | └─┬── ^ ─────────┘         └──────┬─┘         · ....          Final
  |   ·   ·                           ·                           User
  |   ·   └······(3) Authorization ··─┘                        (Resource
  |   ·              Response ("token")                         Owner)
  |   ·                                                         
  |   └···> ..... ··> (4) HTTP Request  ···> │ Resource │ REST/gRPC/.. API.
  |        └──┬──┘    with access_token      │ Server   │
  |  ┌─······─┘       (access denied if 
  |  ·                 access_token is invalid due to wrong signature,...)
  |  ·                                       
  |  ¹ It can be:             
  |    - a direct path between OAuth Client App and OAuth provider,
  |      as in SPA/Native Apps, or 
  |    - a request to a remote API that finally access the resource.
  |      In that case the token must be safely shared between OAuth Provider
  |      and 3rd party API server in a safe way.
  |      Note: From the OAuth point of view the 3rd party API is the
  |            Client App and the Client App In this diagram is just an
  |            (untrusted) User-Agent, not allowed access.
  | 
  |  ¹ Final registered applications from service providers (Client Apps or
  |     3rd-party Service providers) do NOT store password/biometrics locally.
  |    They just **accept signed proofs of identity or authorization
  |    from the trusted OAuth Authentication Provider ** (JWT token in practice).
  |     The signed proof indicates the effecitve roles for a given user.
  |     Only the Authentication server stores passwords, ...
  |    In such sense, it acts as a "firewall" or "bastion" or identity central
  |    controller for the final service providers.
  ```

* OAuth Request/Response Summarized Flow:
  ```
  ---------------------------------------------------------------
  * (Sec 4.1) Authorization Code Grant:
    Only the 3rd party API is authorized, while the User-Agent
    is not trusted.
    The OAuth response does NOT return the access-token, just 
    a *code* to the untrusted User-Agent. then a second Access
    Token Request/Response is required between
    3rd party App and OAuth Provider to obtain the access-token.
  ---------------------------------------------------------------
  * (Sec 4.2) Implicit Grant:
    Optimized for public clients known to operate a particular redirection URI.
    typically implemented in JS in a browser.
    * access-token is returned directly to the user-agent.
    * No refresh token is returned since 
    * Client must be capable of interacting with user-agent 
      and of receiving incoming requests (via redirection)
      from the authorization server.
    * access_token returned directly in Authorization Response.
    * client authentication is not included relying on the presence
      of the resource owner and the registration of the redirection 
      URI.
    * access token is encoded into the redirection URI, it may be
      exposed to the resource owner and other applications residing 
      on the same device.
  ---------------------------------------------------------------
  * (Sec 4.3) Resource Owner Password Credentials Grant 
    * suitable when resource owner has a trust relationship with
      the client protected by HSM, or highly secured app.
    * Clients must be capable of obtaining the resource owner's
      credentials (username/password,...)
    * Less secure, it must be a last resort when other flows
      are not viable.
    * It follows a direct Client/OAuth Provider Request/Response flow. 
  ---------------------------------------------------------------
  * (Sec 4.4) Client Credentials Grant 
    Simplest grant machine-to-machine Authentication
    An specific user's permission to access data is NOT required.
  ---------------------------------------------------------------
  * (Sec 4.5) Extension Grants
  ---------------------------------------------------------------
  * Refresh token grant.

  ```

## User and App Onboarding to OAuth Providers [[{doc_has.key-point]]

* A normal OAuth provider will decouple next two core functionalities:
  1. **User onboarding**
     * Identifying new users (through biometrics, email/pass, ..)
     * Providing user with some method to identify itself in future logins.
  2. **Application registration**.
  Doing so allows the OAuth provider to link users and group of users to
  different applications with different permissions: 
  * A same user can have different permissions in different applications:<br/>
    User A can be "super user" or Administrator of App A, but just a
    "restricted user" of App B while it has absolutely no access to App C.

* In general, the mapping between onborded users and permission for a given
  app is done through two degrees of indirection.
  1. Application Roles: Each final registered application in the OAuth
     provider will define a set of roles. Each role assigned to a given
     user will allow/deny a set of actions in the final application.
  2. Groups of users: For a given app with many users, roles are assigned
     to groups, and users are registered/unregistered from one or more
     group, just to simplify administration. A group can mentally map to
     a department or category. Then roles are assigned by department and
     users registed/unregistered.
[[doc_has.key-point}]]

* `Authorization Request.Scope`:<br/>
   *  When an app is registered as an OAuth client **to access another
      existing server app** it indicates what (permission) scopes it
      wants access to. Ex: <br/>
      My custom App A wants "read contacts" scope to read
      e-mail contacts from Gmail on behalf of the real user.<br/>
   * In practice, when the user first access the App A, it will be
     redirected to the OAuth Server and will be prompted to allow or
     deny "App A" the "read contacts" scope through a popup like UI.
   * Finally issued access-tokens will be limited (scoped) to the
     to granted -by user- scopes.
   NOTES 
   * No particular scopes ared defined in OAuth spec
     (highly dependent on service's internal Architecture)
   * OAuth Server can further limit the set of scopes (permission)
     granted to App due to global security policies.

## (Sec 4.3) OAuth "RESOURCE OWNER CREDENTIALS" GRANT
  ```
  |                                              ┌──────────────────┐
  |┌──────┐           ┌──────────┐               │OAuth Client      │
  |│OAuth │           │Remote App│               │(REST API/Browser/│
  |│Server│           └────┬─────┘               │ Mobile App)      │
  |└┬─────┘                │                     └────────────────┬─┘
  | │                      │<··························· 1) GET ..┤
  | │                      │   2) signed bearer                   │
  | │                      │·┐    access token                    │
  | │                      │<┘    not found                       │
  | │                      ├ 3) redirect to OAuth2 Server ········>
  | │                      │                                      │
  | │ <······· 4)  GET oauth2/token?client_id=...&client_secret=..┤
  | │                      │                                      │
  | │ "POPUP"                                                     │
  | │ ¿user credentials?  ¿scope/s granted?                       │
  | ├·····························································>
  | │                      │                                      │
  | │<····················································5) POST ┤
  | │ {                                                           │
  | │   grant_type   : "password"          ┐ OAuth data           │
  | │   client_id    : ${APP.clientID}     │ identifying the      │
  | │   client_secret: ${APP.secret}       │ pre-registered       │
  | │   scope        : ${SPACE_SEP_SCOPES} ┘ Application/Service  │
  | │                  (OAuth server can further restrict the set │
  | │                   according to company policies)            │
  | │   username       ${username}         ┐ User's credentials   │
  | │   password       ${password}         ┘                      │
  | │ }                                                           │
  | │       (OAuth server can also require extra MFA/biometric    │
  | │        credentials in addition to the username and pass)    │
  | │·┐ 6) Check user/pass │                                      │
  | │<┘ or/and biometrics  │                                      │
  | │   or/and ...         │                                      │
  | ├· 7) JSON object with with signed tokens ····················>
  | │  {
  | │    token_type   : "Bearer"                                  │
  | │    expires_in   : ...                                       │
  | │    access_token : ...  <·· Attach to App's requests         │
  | │    refresh_token: ...  <·· used to refresh tokens           │
  | │  }                   │                                      │
  |┌────────────┐          ┌──────────┐         ┌─────────────────┴┐
  |│OAuth Server│          │Remote App│         │OAuth Client      │
  |└────────────┘          └──────────┘         │(REST API/Browser/│
  |                                             │ Mobile App)      │
  |                                             └──────────────────┘
  ```

## (sect.4.4) OAuth client credentials grant (M2M)
*
  ```
  | client -> OAuth Server: POST
  |                         (grant_type, client_id, client_secret, scope)
  | OAuth Server -> client: {
  |                           token_type = "bearer"
  |                           expires_in
  |                           access_token (Signed JWT token)
  |                         }
  | client -> Service     : Request Using access_token
  | Service -> Service    : Validate signature in access_token
  ```

## AUTHORIZATION CODE GRANT (3rd party apps access) [[{]]
* (Section 4.1)
* User want's to use a 3rd party app that simultaneously
  access some resource in an existing app.

1. STEP 1: Authenticating user and getting Auth. code
  ```
  | participant "OAuth Server"  as OAS
  | participant "3rd party App" as App3rd
  |
  | participant "Web/Native App" as browser
  |
  | App3rd party registered with OAuthServer obtaining App3rd_client.id
  |
  | browser -> App3rd : req resource
  | App3rd -> browser : NO access_token found in request. Redirect
  | browser -> OAS    : redirect to https://OAuthServer/oauth2/token
  |                    ?response_type=${value_code}
  |                    &client_id=${App3rd_client.id}
  |                    &redirect_uri=${REDITECT_URI} <·· (Optional if pre-registered URI)
  |                    &scope=${SPACE_DELIMITED_SCOPES}
  |                    &state=${OPTIONAL_STATE}
  |                           └──────┬────────┘
  |                           highly recommended to avoid "mixing"
  |                           different browser's session on callback
  | browser <- OAS    : Credentials?
  | browser -> OAS    : "Credentials" proof (user/pass and/or MFA and/or ...)
  | OAS     -> OAS    : validate or abort
  | OAS     -> browser: Redirect to ${REDITECT_URI}
  |                     ?code=${AUTHORIZATION_CODE}
  |                     ?state=${COPY_OF_INPUT_STATE_IN_REQUEST}
  | browser -> App3rd : ${REDITECT_URI}?code=....&state=...
  | App3rd -> App3rd  : check Initial State = Received state
  |                     (Avoid mixing different user sessions)
  |                     Associate code to user's session
  ```

2. STEP 2: Using `code` to get Access Token
  ```
  | App3rd -> OAS: POST
  |                grant_type="authorization_code"
  |                client_id=${App3rd_client.id}
  |                client_secret=...
  |                redirect_uri=${ORIGINAL REDIRECT URI}
  |                code=${CODE}
  | OAS -> App3rd: JSON object
  |                token_type     usually "Bearer"
  |                expires_in     access token TTL(Integer)
  |                access_token   the access token itself
  |                refresh_token  used refresh on expiration
  |                               time
  ```
[[}]]

[[protocol.OAuth}]]

# OpenID Connect [[{protocol.OpenID.connect,use_case.authentication,]]
* OpenID 2 (precedes OpenID Connect):
  * created for FEDERATED ("delegated" to 3rd-party) authentication,
    while don't forcing users to pre-select or negotiate with providers
    to allow them to employ any other account they have.
  * 1+ billions OpenID-enabled accounts on the Internet as of 2016.
  * OIDC2 providers include Google, WordPress, Microsoft, ...

NOTE: Confusingly enough, authorization is also considered some time a
form of pseudo-authentication and OAuth2 is claimed to be an
authentication standard while it is designed as Authorization by design.
(An authorization signed token is a claim that the user is believed
 to be himself for the act of executing an action or accesing 
 some resource).

NOTE: OpenID Connect can also be seen as a "transport" for Credencitials.
In such sense, next alternatives can be cited:
* DIDComm               : <https://identity.foundation/didcomm-messaging/spec/">
* Credential Handler API: <https://w3c-ccg.github.io/credential-handler-api/>
* SAML v2               : <https://saml.xml.org/saml-specifications>
or any other transport envelope. 


Summary from <https://openid.net/specs/openid-connect-core-1_0.html>)

* OpenID Connect improves over OpenID by allowing end-users to log
  in once and access "random" remotes resources with an API "friendly"
  to web and mobile native apps, without the extensions required
  by OpenID. OID-Connect standardizes:
  * scopes:
  * endpoint discovery:
  * dynamic registration of clients:
* OpenID Connect (2014) combines the features of OpenID 2.0, OpenID
  Attribute Exchange 1.0, and OAuth 2.0 in a single protocol, it
  allowing Application clients to obtain End-User identity verifiable
  (signed) Claims using the new IANA registered JWT **ID Token**.

## Nomenclature <!-- { -->

### Main Components/Actors:
* `OpenID Provider (OP)`: OAuth 2.0 Provider implementing the OpenID Connect extensions.
  It issues Identity claims in the ID Token in addition to the standard authorization
  `access_token` in OAuth 2.  (or has control over the real Issuer).<br/>
  End-Users are assigned a locally unique and never reassigned Subject Identifier on it<br/>
  Issuer Identifiers follow the `https://host:port/path?query` scheme.
  It contains the https endpoints (URL protected Resources):
  ```
  * token    endpoint:  <·· standard OAuth endpoints
  * ... (TODO)
  * UserInfo Endpoint:  <·· OpenID Connect Extension. When presented with an
                            standard OAuth 2 access_token by the Client, it
                            returns authorized information about the End-User
                            represented by the corresponding Authorization Grant.
                            content-type := application/json | application/jwt
  ```
* **Self-Issued OpenID Provider: Personal, self-hosted OpenID Provider that issues self-signed ID Tokens.
  In practice, a wallet that signs ID Tokens against a DID or publick key that it can prove to control
  by signing with the private key.<br/>
  **Self-Issued OPs use the special Issuer Identifier `https://self-issued.me`**
* OpenID Client or Relying Party (RP): OAuth 2.0 Client app (native/web or REST API) implementing
  the OpenID Connect extensions. In some Identity texts the Relying Party is the legal actor while
  the OpenID Client is the software component.<br/>
  The OIDC Application Client initiates a new OpenID flow by creating a new OpenID Authorization
  Request (OAuth Request extension). The request is "forwarded" to the User Agent ("Browsers"
  or native apps) and from there to the OP Authorization Endpoint.
* User-Agents: Native app or browser in control of final users to interact with OIDC Providers and
  Relying Parties. In "native" web apps (web applications with the logic "embedded" in Javascript)
  the user-agent is also the OpenID clients, but in many scenarios the Javascript application
  access a remote API, and it is such remote API (server) the one with the role of OpenID Client.
  Such remote API is the one with control of the ID-token, skipping the User-Agent (see Authorization
  Code Grant later on).
* Authentication Context Class: Set of authentication-methods or procedures that are considered to
  be equivalent to each other in a particular context. (for example, military, high, medium, low)

* The summarized sequence diagram to obtain the ID-token from the UserInfo end-point follows:
  ```
  |   --- PRE-SETUP --------------------------------------------------
  |   Relying ¹                       OpenID²
  |   Party                      provider(OP)                       End-User
  |   ┬                                    ┬                         ┬
  |   │                                    │<··· Req. OIDC Account ··┤
  |   │                                    ├─·· alice.myIDOP.org ···>│
  |   ·                                    ·                         ·
  |   │<── OP Admin pre-registers the   ──>│                         ·
  |   │   App with an Application ID,      │  
  |   ·   shared secret, redirect_uri      ·  
  |   ·   callback, ...                    ·
  |   ·                                    ·
  |   --- IDENTITY FLOW ("happy path") -------------------------------
  |   Relying ¹                      OpenID²
  |   Party                     provider(OP)                        End-User
  |   ┬                                    ┬                         ┬
  |   ├─(1) AuthN Request ⁵ ··············>│                         │
  |   │  ex: HTTP 302 response (by Client) ├<(2) Authen.+Authori.···>┤
  |   │  which triggers the User Agent to  │     On error OP informs like ⁶: [[{qa.error_mng}]]
  |   │  make an Auth.Request to OP:       │     HTTP/1.1 400 Bad Request
  |   │  HTTP/1.1 302 Found                │     Content-Type: application/json
  |   │  Location: https://a.b.c/authorize?│     Cache-Control: no-store
  |   │   response_type=code               │     Pragma: no-cache
  |   │   &scope=openid%20profile%20email  │     { "error": "invalid_request" }
  |   │   &client_id=s6BhdRkqt3            │     (Section 4.1.2.1@RFC6749(OAuth 2.0)
  |   │   &state=af0ifjsldkj               │
  |   │   &redirect_uri=https%3A%2F%2Fd.e.f%2Fcb
  |
  | ┌──alt A³: Implicit flow  ──────────────┐ <·· Apps runs in mobile/Web+JS (with an
  | │ │                                   │ │     embedded user-agent).
  | │ │<·(3) ID token+(opt)access_token ·─┤ │
  | │ ├<···············(3) access_token ·─┤ │
  | │ │                                   │ │
  | ├──alt B⁴: Authorization Code flow ─────┤ <·· Front-end runs in mobile/Web, but APIs
  | │ │                                   │ │     runs in backend-servers. The front-end
  | │ ├<···············(3) access_token ──┤ │     has a non-trusted user agent.
  | │ │     HTTP/1.1 302 Found            │ │
  | │ │     Location: https://d.e.f/cb?   │ │
  | │ │       code=SplxlOBeZQQYbYS6WxSbIA │ │
  | │ │       &state=af0ifjsldkj          │ │
  | │ ├─(4)(Opt)UserInfo Req(+acc.Token)─>│ │
  | │ │<·· (5) UserInfo JSON/JWT Resp. ··─┤ │
  | │ │                                   │ │
  | ├──alt C: Hybrid Flow           ────────┤ <·· Custom setups.
  | │ │ ... other Response Types defined  │ │
  | │ │ in OAuth2.0 Multiple Resp.Type    │ │
  | │ │ encoding practices...             │ │
  | └───────────────────────────────────────┘
  |
  |  NOTE: All Token Responses with tokens/secrets info.  [[{security.secret_mng,troubleshooting}]]
  |        MUST include the HTTP response headers:
  |          Cache-Control: no-store
  |          Pragma       : no-cache
  |
  |  ¹⁾ In general Client ID+User-Agent.
  |  ²⁾ In Self Issued OpenID, the OP is a "wallet".
  |  ³ alt A Client is a final native mobile or web app.
  |  ⁴ alt B Client is REST API. User-Agent is not trusted
  |       This degree of indirection avoids sending the
  |       ID-Token directly to the trusted User-Agent.
  |       all tokens are returned from the Token Endpoint,
  |       and they must not be available to the User-agent.
  |       * An Authorization Code is received by the user-agent
  |         that "forwards" to the Client. The client finally
  |         exchanges it for the ID Token.
  |  ⁵ ┌─ Request Params: ────────────────────────────────────────────────────────────────────
  |    │ scope* ····· openid(mandatory),  profile|email|phone
  |    │              If response_type==id_token, profile,email,... must be included 
  |    │              The OP can further filter out some scopes according to established
  |    │              security/organization policies.
  |    │ response* ·· including parameters returned from the endpoints used.
  |    │     _type    The ID-TOken flow used is determined by its value:
  |    │                "response_type"        Flow
  |    │                code ················> Auth. Code Flow
  |    │                id_token ············> Implicit Flow
  |    │                id_token token ······> Implicit Flow
  |    │                value ¹ ·············> Implicit Flow
  |    │                code id_token ·······> Hybrid Flow
  |    │                code token ··········> Hybrid Flow
  |    │                code id_token token ·> Hybrid Flow
  |    │               ¹ Defined in OAuth 2.0, not used in OpenID Connect,
  |    │                 since no ID Token would be returned.
  |    │ client_id* ·· OAuth 2.0 Client Identifier valid at the Authorization Server.
  |    │ redirect_uri* https URI to which the OP response will be sent (if required)
  |    │             matching exactly one pre-registered Redirection URI.
  |    │             (http allowed for confidential ("localhost") Client Type.
  |    │             native apps can use alternative deep-links callback schemes.
  |    │ state* ···· Opaque value to related request and response.
  |    │             Typically, Cross-Site Request Forgery (CSRF, XSRF) mitigation is done  [[{PM.TODO}]]
  |    │             by cryptographically binding  it with a browser cookie.
  |    │ response ·· (OpenID extension), mechanism to be used for returning parameters from the
  |    │  -mode      Authorization Endpoint. Use NOT RECOMMENDED when Response Mode is default
  |    │             one for the Response Type.
  |    │ nonce*  ··· OpenID extension to protect against replay attacks.
  |    │ display ··· Authentication and consent-user interface pages requested to the OP to
  |    │             render to End-User. :=
  |    │             := (full) page* | popup | touch | wap ("feature phone")
  |    │ prompt  ··· case sensitive space separated prompts that the OP shows to End-User. Values:
  |    │             +    none: Display nothing. "login_required", ... is returned if not yet authenticated
  |    │             +   login: prompt End-User for reauthentication.
  |    │             + consent: Prompt End-User for consent 
  |    │             + select_account: Prompt End-User for a user account.(when N are available)
  |    │             prompt can also be used to make sure End-User is still present
  |    │ max_age  ·· Seconds since last time the End-User was actively authenticated.
  |    │ ui_locales  ex. "fr-CA fr en" (in order of preference)
  |    │ id_token ·· ID-Token previously issued. If End-User NOT YET logged in "throw" error
  |    │   _hint     When possible, it SHOULD be present for prompt=none.
  |    │ login_hint  Hint to OP about login identifier the End-User might use to log in
  |    │             For example an e-mail or phone number, ...
  |    │ acr_values  Requested (as a Voluntary Claim) Auth.Context Class Ref.values.
  |    │ claims  ··· "optional" JSON list of Claims.
  │    └──────────────────────────────────────────────────────────────────────────────────────
  |
  | Standard claims returned in JWT ID token(3) or UserInfo response (4) include:
  | │ MEMBER ········ TYPE   ·· DESCRIPTION                                         
  | │ sub  ·········· string ·· Subject Identifier for End-User at the Issuer.      
  | │ name ·········· string ·· End-User's **full** name in displayable form        
  | │                           including all name parts, possibly including titles 
  | │                           and suffixes, ordered according to the End-User's   
  | │                           locale and preferences.                             
  | │ given_name ···· string ·· first name(s) of End-User, white-space separated.   
  | │ family_name ··· string ·· last name(s) of End-User, white-space separated.    
  | │ middle_name ··· string ·· Middle name(s) of End-User white-space separated.   
  | │ nickname  ····· string ·· Casual name of the End-User                         
  | │ preferred ····· string ·· Shorthand name by which the End-User wishes to be   
  | │ _username                 referred to at the RP, such as janedoe or j.doe.    
  | │                           value MAY be any valid JSON string including special
  | │                           characters such as @, /, or whitespace. RP MUST NOT 
  | │                           rely upon this value being unique.                  
  | │ profile ······· string ·· URL of the End-User's profile page.                 
  | │ picture ······· string ·· URL of End-User's profile picture. URL MUST refer   
  | │                           to an (PNG, JPEG, ...) image file, rather than to a 
  | │                            Web page containing an image.                      
  | │ website ······· string ·· URL of the End-User's Web page or blog.             
  | │ email ········· string ·· End-User's preferred e-mail address.                
  | │                           RP MUST NOT rely upon this value being unique.      
  | │ email ········· boolean·· (verified by Auth.Provider)                         
  | │ _verified                                                                     
  | │ gender ········ string ·· := female | male | "other values" MAY be used       
  | │ birthdate ····· string ·· YYYY-MM-DD format. Year MAY be 0000 to omit it.     
  | │                           YYYY       format, avoiding MM-DD                   
  | │ zoneinfo ······ string ·· zoneinfo time zone database. Europe/Paris,...       
  | │ locale ········ string ·· BCP47/RFC5646 language tag, ex: en_US;              
  | │ phone_number ·· string ·· E.164 is the RECOMMENDED format.Ex:                 
  | │                            +1 (425) 555-1212, +56 (2) 687 2400, ...           
  | │ phone_number ·· boolean · (verified by Auth.Provider)                         
  | │  _verified                                                                    
  | │ address ······· JSON obj· preferred postal address. value is a JSON [RFC4627] 
  | │                           structure containing some|all members in Sec.5.1.1. 
  | │ updated_at ···· number ·· JSON secs. since 1970-01-01T0:0:0Z measured in UTC  
  | │ at_hash    ···· string ·· Optional for Auth. Code FLow.                       
  | │                           Access Token hash value. Ex:                        
  | │                           alg==RS256 => SHA-256(access_token)                 
  | │                             => take left-most 128 bits => base64url           
  |
  | JWT ID token(3) in the Implicit Flow contains also:
  | iss*. Case sensitive URL using https-scheme Issuer identifier.
  | sub*. Up to 255 ASCII chars, case-sensitive, Subject Identifier
  | aud*. string[] case sensitive. Audience(s) this ID Token is intended
  |       for. It MUST contain at least the OAuth 2.0 pre-registered  lient_id of
  |       Relying Party.
  | exp*. Expiration Time,  "now"-UTC since 1970-01-01T0:0:0Z secs number
  | iat*. Issued at  Time secs. OIDC clients can reject based on value.
  | auth_time: Time when End-User authentication occurred. REQUIRED when max_age
  |       or auth_time itself is also required.
  | nonce: case-sensitive String value used **to associate a Client session with
  |       ID Token, and to mitigate replay attacks.
  |       Generated by Client in initial Auth. Request, returned "as is".
  |       Client MUST verify that the nonce Claim Value has not changed.
  | acr: Authentication Context Class Reference String satisfied
  |      value "0" => End-User Authentication did not meet requirements of
  |                   ISO/IEC 29115 [ISO29115] level 1. SHOULD NOT be used to
  |                   authorize access to any resource of any monetary value.
  |                   It corresponds to OpenID 2.0 PAPE nist_auth_level 0.
  |      absolute URI or RFC 6711 registered name SHOULD be used as value
  |      Example: "urn:mace:incommon:iap:silver"
  | amr: OPTIONAL. string[] of Authentication Methods References. Values might
  |      indicate that both password and OTP authentication methods were used.
  | azp: OPTIONAL. String|URI OAuth 2.0 Client ID Authorized party
  |      REQUIRED when the ID Token has a single audience and it differs from
  |      Authorized party.
  ```
<!-- } -->
*  Flow comparative
  ```
  |              Hybrid Flow  ··········─┐
  |            Implicit Flow  ······─┐   ·
  |  Authorization Code Flow  ···┐   ·   ·
  |                              ·   ·   ·
  |  Property                    v   v   v
  |  All tokens returned ····· │no │yes│no
  |     from AuthoEndpoint     │   │   │
  |  All tokens returned ····· │yes│no │no
  |      from Token Endpoint   │   │   │
  |  Tokens not revealed  ···· │yes│no │no  [[{doc_has.key-point}]]
  |      to User Agent         │   │   │
  |      (browser)!!!          │   │   │
  |  Client can be ··········· │yes│no │yes
  |      authenticated         │yes│no │yes
  |  Refresh Token possible .. │yes│no │yes
  |  Communication in ········ │no │yes│no
  |     one round trip         │   │   │
  |  Most communication ...... │yes│no │Y/N
  |  server-to-server          │   │   │
  ```
* JWS ID Tokens MUST optionally both JWS signed or JWS signed->JWE encrypted (Nested JWT).
* ID Tokens SHOULD NOT use the JWS or JWE x5u, x5c, jku, or jwk Header Parameter fields.
  Instead, **references to keys used are communicated in advance using Discovery and
  Registration parameters, per Section 10.**
* Unless the Redirection URI is invalid, the Auth.Server returns the
  Client to the Redirection URI specified in the Authorization Request
  with the appropriate error and state parameters. Other parameters
  SHOULD NOT be returned.
* error response parameters are the following:
  ```
  | error*            : Error code ¹
  | error_description : Human-readable
  | error_uri         : web page with additional info.
  | state             : REQUIRED if provided in Auth.Request
  | 
  | ¹ error codes (in addition to errors in OAuth2):
  |   invalid_request_uri        : (in Auth.Request)
  |   invalid_request_object     : 
  |   interaction_required       : OP requires End-User interaction 
  |   login_required             :
  |   account_selection_required :
  |   consent_required           :
  |   request_not_supported      : request      param  not supported by OP.
  |   request_uri_not_supported  : request_uri  param. not supported by OP.
  |   registration_not_supported : registration param. not supported by OP.
  |                                as defined in Section 7.2.1.
  | 
  | Example Authorization Code Flow error response:
  | 
  |   HTTP/1.1 302 Found
  |   Location: https://client.example.org/cb?
  |     error=invalid_request
  |     &error_description=....
  |     &state=1234
  ```

* Authentication Response Validation
  * (Open ID Application) Client makes a Token Request by presenting its Authorization Grant
    (in the form of an Authorization Code) to the Token Endpoint using `grant_type` value
    authorization_code, as described in Section 4.1.3 of OAuth 2.0 [RFC6749].
  * If the Client is a Confidential Client, then it MUST authenticate to the Token Endpoint
    using the authentication method registered for its client_id, as described in Section 9.
  * The Client sends the parameters to the Token Endpoint using the HTTP POST method and
    Form Serialization, per Section 13.2, as described in Section 4.1.3 of OAuth 2.0 [RFC6749].
  * non-normative example of Token Request:
    ```
    | POST /token HTTP/1.1
    | Host: server.example.com
    | Content-Type: application/x-www-form-urlencoded
    | Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW
    |
    | grant_type=authorization_code&code=SplxlOBeZQQYbYS6WxSbIA
    |   &redirect_uri=https%3A%2F%2Fclient.example.org%2Fcb
    ```

* 3.1.3.2. Token Request Validation by Auth.Server (from Client App)
  * Authenticate the Client if it was issued Client Credentials or if
    it uses another Client Authentication method, per Section 9.
  * Ensure the Authorization Code was issued to the authenticated Client.
  * Verify that the Authorization Code is valid.
    If possible, verify that the Authorization Code has not been
    previously used.
  * Ensure that `redirect_uri` value is identical to the original
    value included in the initial Auth.Request. If not present
    the OP MAY return an error or proceed.
  * Verify that the Authorization Code used was issued in response
    to an OpenID Connect Authentication Request.

* non-normative example of successful Token Response:
  ```
  | HTTP/1.1 200 OK
  | Content-Type: application/json
  | Cache-Control: no-store
  | Pragma: no-cache
  |
  | {
  |  "access_token": "SlAV32hkKG",
  |  "token_type": "Bearer",
  |  "refresh_token": "8xLOxBtZp8",
  |  "expires_in": 3600,
  |  "id_token": "eyJhbGciOiJSUzI1NiIsImtpZCI6IjFlOWdkazcifQ.ewogImlzc
  |    yI6ICJodHRwOi8vc2VydmVyLmV4YW1wbGUuY29tIiwKICJzdWIiOiAiMjQ4Mjg5
  |    NzYxMDAxIiwKICJhdWQiOiAiczZCaGRSa3F0MyIsCiAibm9uY2UiOiAibi0wUzZ
  |    fV3pBMk1qIiwKICJleHAiOiAxMzExMjgxOTcwLAogImlhdCI6IDEzMTEyODA5Nz
  |    AKfQ.ggW8hZ1EuVLuxNuuIJKX_V8a_OMXzR0EHR9R6jgdqrOOF4daGU96Sr_P6q
  |    Jp6IcmD3HP99Obi1PRs-cwh3LO-p146waJ8IhehcwL7F09JdijmBqkvPeB2T9CJ
  |    NqeGpe-gccMg4vfKjkM8FcGvnzZUN4_KSP0aAp1tOJ1zZwgjxqGByKHiOtX7Tpd
  |    QyHE5lcMiKPXfEIQILVq0pc_E2DzL7emopWoaoZTF_m0_N0YzFC6g6EJbOEoRoS
  |    K5hoDalrcvRYLSrQAZZKflyuVCyixEoV9GfNQC3_osjzw2PAithfubEEBLuVVk4
  |    XUVrWOLrLl0nx7RkKU8NXNHq-rvKMzqg"
  | }
  ```
* If ID Token is received via direct token endpoint -> TLS -> Client
  TLS server validation MAY be used to validate the issuer in place of
  checking the token signature.

##  Initiating Login from a Third Party
* In some cases, login flow is initiated by an OpenID Provider or another party,
  rather than the Relying Party.
* In this case, the initiator redirects to the RP at its login initiation endpoint,
  which requests that the RP send an Authentication Request to a specified OP.
  (See original spec for further details).

5.1.1.  Address Claim
  ```
  | One of:
  | := formated full address as single string
  | :=  { .. } individual component fields
  | := full address + { ...} individual fields.
  |     formatted: Full maybe-multiline mailing address formatted for display.
  |     street_address: Full street address component (house number and/or street name and/or Post Office Box, ...)
  |     locality: City or locality component.
  |     region: State, province, prefecture, or region component.
  |     postal_code: Zip code or postal code component.
  |     country: Country name component.
  ```

* Additional Claims MAY be used (5.1.2.) using collision-resistant names.

* UserInfo Endpoint SHOULD support the use of Cross Origin Resource Sharing (CORS) and
  or other methods as appropriate to enable Java Script Clients to access the endpoint.

* Scope Values:
  * profile: default profile Claims: name, family_name, given_name,
             middle_name, nickname, preferred_username, profile,
             picture, website, gender, birthdate, zoneinfo, locale, updated_at.
  * email - address - phone
* Claim type by assert origin:
  ```
  | Normal      ¹ asserted by OP.
  | Aggregated  ² asserted by 3rd party Claims Provider,
  |               returned as val. by OP.
  | Distributed ² asserted by 3rd party Claims Provider,
  |               returned as Ref. by OP.
  | * ¹: mandatory, ²: optional
  |
  | Normal Claims MUST be supported.
  | Aggregated&Distributed Claims are OPTIONAL.
  ```

### request vs request_uri Authorization Request parameters:

* request:  OPTIONAL. enable requests to be passed in a self-contained JSON+base64url o JWT (if signed and/or encrypted)
            whose Claims are the request parameters.
* request_uri: OPTIONAL. enables requests to be passed by https reference, rather than by value.
            (particularly useful for large requests encoded in QR, ...).

* non-normative example of the Claims in a Request Object before base64url encoding and signing:
  ```
  | {
  |  "iss": "s6BhdRkqt3",
  |  "aud": "https://server.example.com",
  |  "response_type": "code id_token",
  |  "client_id": "s6BhdRkqt3",
  |  "redirect_uri": "https://client.example.org/cb",
  |  "scope": "openid",
  |  "state": "af0ifjsldkj",
  |  "nonce": "n-0S6_WzA2Mj",
  |  "max_age": 86400,
  |  "claims":
  |   {
  |    "userinfo": {
  |      "given_name": {"essential": true},
  |      "nickname": null,
  |      "email": {"essential": true},
  |      "email_verified": {"essential": true},
  |      "picture": null
  |    },
  |    "id_token": {
  |      "gender": null,
  |      "birthdate": {"essential": true},
  |      "acr": {"values": ["urn:mace:incommon:iap:silver"]}
  |    }
  |   }
  | }
  ```

* Signing it with the RS256 algorithm results in this Request Object
  value (with line wraps within values for display purposes only):

  eyJh...  ~1300 base64enc chars ~
* non-normative example of an Authorization Request using the request parameter
  ```
  https://myOIDC.mycomp.com/authorize?
    response_type=code%20id_token
    &client_id=s6BhdRkqt3
    &redirect_uri=https%3A%2F%2Fclient.example.org%2Fcb
    &scope=openid
    &state=af0ifjsldkj
    &nonce=n-0S6_WzA2Mj
    &request=eyJhbGc... <·· JSON reques base64url encoded
  ```

* non-normative example of an Authorization Request using the request_uri parameter.
  ```
  https://server.example.com/authorize?
    response_type=code%20id_token
    &client_id=s6BhdRkqt3
    &request_uri=https%3A%2F%2Fclient.example.org%2Frequest.jwt%23GkurKxf5T0Y-mnPFCHqWOMiZi4VS138cQO_V7PZHAdM
    &state=af0ifjsldkj&nonce=n-0S6_WzA2Mj
    &scope=openid
  ```

## 7.  Self-Issued OpenID Provider

* Self-Issued OpenID Providers: personal, self-hosted OPs that issue self-signed ID Tokens.
* **Self-Issued OPs use the special Issuer Identifier `https://self-issued.me`**
* messages used to communicate with Self-Issued OPs are mostly the same as standard OPs,
  with a few additional parameters.

### 7.1.  Self-Issued OpenID Provider Discovery

* **dynamic discovery is not performed**. Instead, then the following static configuration values are used:

  ```
  {
   "authorization_endpoint"  : "openid:",
   "issuer"                  : "https://self-issued.me",
   "scopes_supported"        : ["openid", "profile", "email", "address", "phone"],
   "response_types_supported": ["id_token"],
   "subject_types_supported" : ["pairwise"],
   "id_token_signing_alg_values_supported": ["RS256"],
   "request_object_signing_alg_values_supported": ["none", "RS256"]
  }
  ```

* No client registration is required for Self-Issued OP.

* The new optional `registration` Authorization Request parameter enable Clients to provide
  additional registration information to Self-Issued OpenID Providers:
  (information that would normally be provided to an OP during Dynamic Client Registration).
  The value is a JSON object containing Client metadata values, as defined in
  Section 2.1 of the OpenID Connect Dynamic Client Registration 1.0 spec.
  * None of this information is REQUIRED by Self-Issued OPs.
  * Registration parameters typically used would be: `policy_uri`, `tos_uri`, `logo_uri`.
    `redirect_uris` (in case of 2+ Redirection URIs exists) and, for Clients
   requesting encrypted responses, `jwks_uri`, `id_token_encrypted_response_alg` and
   `id_token_encrypted_response_enc`.

* Standard OIDC Provider Request in Self-issued OIDC include:
  * scope:  REQUIRED. with same meaning as in standard OIDC.
  * response_type: REQUIRED. **Constant string value id_token**<br/>
    NOTE that all Claims are returned in the ID Token.
  * client_id: REQUIRED. **Client ID value for the Client, which
    in this case contains the redirect_uri value of the Client.**:<br/>
  * ~redirect_uri~~ not required since it is equal to cient_id.
  * id_token_hint: OPTIONAL. as in standard OIDC.
  * claims: OPTIONAL. as in standard OIDC.
  * registration: OPTIONAL. Self-OIDC extension as explained previously.
  * request: OPTIONAL. as in standard OIDC.
  * Other parameters MAY be sent.

* non-normative example HTTP 302 redirect response by the Client,
  which triggers the User Agent to make an Authentication Request to
  the Self-Issued OpenID Provider (with line wraps within values for display purposes only):

  ```
  HTTP/1.1 302 Found
  Location: openid://?
    response_type=id_token
    &client_id=https%3A%2F%2Fclient.example.org%2Fcb
    &scope=openid%20profile
    &state=af0ifjsldkj
    &nonce=n-0S6_WzA2Mj
    &registration=%7B%22logo_uri%22%3A%22https%3A%2F%2F
      client.example.org%2Flogo.png%22%7D
  ```

### 7.4. Self-Issued OpenID Provider Response

* SSI OP response is equal to normal Implicit Flow response with next refinements:
  * Implicit Flow response => response parameters will be returned in the URL fragment component,
    unless a different Response Mode was specified.
  * `iss=https://self-issued.me`
  * `sub_jwk` required. Public key used to check signature of self-issued ID Token.
     A Claim is present, with value being public key used to check signature of ID Token.
  * `sub=base64url representation of thumbprint of key in the sub_jwk Claim`.
  * No Access Token is returned for accessing a UserInfo Endpoint, so all Claims
    returned MUST be in the ID Token.

* Check 7.5.  for Self-Issued ID Token Validation

## 8 Subject Identifier Types

  ```
  public  : same sub value sued for all Clients.
  pairwise: Provides a different sub value to each Client.
            See section 8.1 in RFC for details.
  ```

## 9.   Methods Client-to-OpenID Provider Authentication

* `client_secret_basic`: Clients receives in presetup a `client_secret`
  from Auth.Server (RFC6749, Section 2.3.1 OAuth 2.0 ) using HTTP Basic
  authentication scheme.
* client_secret_post:  similar to client_secret_basic, including Client
  Credentials in the request body.
* `client_secret_jwt`: Client authenticates in accordance with JWT Profile
  for OAuth 2.0 Client Authentication and Authorization Grants and
  Assertion Framework for OAuth 2.0 Client Authentication and
  Authorization Grants [OAuth.Assertions]. See RFC for details.
* `private_key_jwt`: Clients pre-register pub.key


## See section 10 of RFC for details of Signatures and Encryption

### 10.1.1. Rotation of signing keys
* It can be accomplished with the following approach:
  signer publishes its keys in a JWK Set at its jwks_uri location and includes
  the kid of the signing key in the JOSE Header of each message to indicate
  to the verifier which key is to be used to validate the signature.

### 10.2.1.  Rotating encryption keys necessarily:
* It uses a different process than the one for signing keys because the
  encrypting party starts the process and thus cannot rely on a
  change in kid as a signal that keys need to change.  The encrypting
  party still uses the kid Header Parameter in the JWE to tell the
  decrypting party which private key to use to decrypt, however, the
  party needs to first select the most appropriate key from those
  provided in the JWK Set at the recipient's jwks_uri location.
* To rotate keys, the decrypting party can publish new keys at its
  jwks_uri location and remove from the JWK Set those that are being
  decommissioned. The jwks_uri SHOULD include a Cache-Control header in
  the response that contains a max-age directive, as defined in RFC
  2616 [RFC2616], which enables the encrypting party to safely cache
  the JWK Set and not have to re-retrieve the document for every
  encryption event. The decrypting party SHOULD remove decommissioned
  keys from the JWK Set referenced by jwks_uri but retain them
  internally for some reasonable period of time, coordinated with the
  cache duration, to facilitate a smooth transition between keys by
  allowing the encrypting party some time to obtain the new keys. The
  cache duration SHOULD also be coordinated with the issuance of new
  signing keys, as described in Section 10.1.1.

## Offline Access
  ```
  |  "scope" : "openid ... offline_access"
  |                        └──────┬─────┘
  |requests issuance of Refresh Token allowing to obtain a new
  |Access Token granting access to End-User's UserInfo Endpoint
  |when the End-User is not present/not logged in.
  ```
  See original RFC for more details.

* All OpenID Providers MUST implement the following features defined in this specification.
* Signing ID Tokens with RSA SHA-256
* Preferred Locales
* Authentication Time
* Maximum Authentication Age
* Authentication Context Class Reference

*  Mandatory to Implement Features for Dynamic OpenID Providers
  * id_token Response Type and all that are not Self-Issued OPs MUST also support
    the code and id_token token Response Types.
  * Discovery
  * Dynamic Registration
  * UserInfo Endpoint
  * Public Keys Published as Bare Keys
  * Request URI


* Implementers should be aware that this specification uses several
  IETF specifications that are not yet final specifications, including:
  * JSON Web Token (JWT) draft -25 [JWT]
  * JSON Web Signature (JWS) draft -31 [JWS]
  * JSON Web Encryption (JWE) draft -31 [JWE]
  * JSON Web Key (JWK) draft -31 [JWK]
  * JSON Web Algorithms draft -31 [JWA]
  * Assertion Framework for OAuth 2.0 Client Authentication and Authorization Grants draft -17
  * JSON Web Token (JWT) Profile for OAuth 2.0 Client Authentication and Authorization Grants draft -10

### Related Specs:
* OpenID Connect Discovery 1.0
  Defines how Relying Parties dynamically discover information about OpenID Providers
* OpenID Connect Dynamic Client Registration 1.0
  Defines how Relying Parties dynamically register with OpenID Providers
* OpenID Connect Session Management 1.0
  Defines how to manage OpenID Connect sessions, including logout functionality
* OAuth 2.0 Form Post Response Mode
  Defines how to return OAuth 2.0 Authorization Response parameters
  (including OpenID Connect Authentication Response parameters) using
  HTML form values that are auto-submitted by the User Agent using HTTP
  POST

### Related implementer's guides:
* OpenID Connect Basic Client Implementer's Guide 1.0
* OpenID Connect Implicit Client Implementer's Guide 1.0 [OpenID.Implicit]


## OpenID vs SAML [[{02_doc_has.comparative]]

* Both OpenID vs SAML are different security protocols for single sign-on
  Authorization and Authentication.

* SAML is a oldest standard (2001) with latest update in 2005.
* SAML Auth.Servers ends up returning a SAML signed "response assertions"
  (similar to the JSON response in OAuth) containing statements
  about authorization, authentication and/or attributes (emails, phones,...).

* SAML defines:
  * principal (`client` in OAuth).
  * service provider (application / REST API, like in OAuth)
  * Identity provider: (Active Directory, KeyCloak ...) Server holding
    principal's ids + credentials and registered service providers.
* SAML 2.0 defines also:
  * assertions: Signed claims about a principal
  * protocols : assertion requests and responses
  * bindings  : how requests/responses happen between the service provider
                and identity provider using communication methods like
                HTTP POST
  * profile   : allowed combinations of (assertions, protocols, bindings)
                for various use cases, like SSO.

  ```
                   ┌────────────┬─────────────┬─────────────────┐
                   │ OAuth2     │ OpenId      │ SAML            │
  ┌────────────────┼────────────┼─────────────┼─────────────────┤
  │Token format    │ JSON/SAML2 │ JSON        │ XML             │
  ├────────────────┼────────────┼─────────────┼─────────────────┤
  │Authorization?  │ Yes        │ No          │ Yes             │
  ├────────────────┼────────────┼─────────────┼─────────────────┤
  │Authentication? │ Pseudo     │ Yes         │ Yes             │
  ├────────────────┼────────────┼─────────────┼─────────────────┤
  │created on      │ 2005       │ 2006        │ 2001            │
  ├────────────────┼────────────┼─────────────┼─────────────────┤
  │Current version │ OAuth2     │ OpenID      │ SAML 2.0        │
  │                │            │   Connect   │                 │
  ├────────────────┼────────────┼─────────────┼─────────────────┤
  │Transport       │ HTTP       │ HTTP        │ Transport bind- │
  │                │            │ GET/POST    │ ings exits for: │
  │                │            │             │ SAML SOAP       │
  │                │            │             │ HTTP POST       │
  │                │            │             │ GET Redirect    │
  │                │            │             │ others          │
  ├────────────────┼────────────┼─────────────┼─────────────────┤
  │SECURITY RISKS  │ Phishing   │ Phishing    │ XML Signature   │
  │                │            │             │ wrapping to im- │
  │                │            │             │ personate a user│
  ├────────────────┼────────────┼─────────────┼─────────────────┤
  │Best suited for │ API        │ SSO delega- │ enterprise      │
  │                │   Authori- │ ting to     │ Single sign-on  │
  │                │   zation   │ Google,...  │                 │
  └────────────────┴────────────┴─────────────┴─────────────────┘
  ```
[[02_doc_has.comparative}]]
[[protocol.OpenID.connect}]]

# OpenID for Verifiable Presentations [[{protocol.OpenID.OIDC4VP]]
[[use_case.authentication]]
  ```
  | Draft 20: (29 November 2023 )
  | <https://openid.github.io/OpenID4VP/openid-4-verifiable-presentations-wg-draft.html>
  | <https://github.com/openid/OpenID4VP>
  ```

* enables presentation of VCs as Verifiable Presentations on any format 
  (W3C VCs Data Model, ISO mdoc, and AnonCreds [Hyperledger.Indy], ...)
* Built on top of OAuth 2.0, reusing:
  * reuse pre-existing OAuth 2.0 Grant Types (token, code, ...)
  * reuse pre-existing Response mode: 
    * #fragment : Redirect with in URI framents   - with vp_token in Authorization (Header?).
    * ?query    : Redirect with in URI query param- with vp_token in Authorization (Header?).
    * In that case the new `Authentication Request.response_mode` is also
      used.  (Otherwise the default #fragment or ?query is used according 
      to the default used in the grant-type).
    * Also used to request signing or signing+encrypting. 
* New `Authentication Request` response types defined in spec: 
  * `vp_token` and  `vp_token id_token`: (request VPs 
    in Authorization Responses (standalone or along with a Self-Issued
    ID Token [SIOPv2]):
    * A VP Token contains 1+ single Verifiable Presentations in one or
      different formats.
* OIDCVP contemplate also cross-device scenarios:
  ```
  |      ORIGIN                                         DESTINATION
  |      OAuth Client ··> OAuth Auth.Request(_uri)¹···> Web browser   
  |      (Verifier)       (HTTP 302 Redirect)           └────┬────┘
  |                       #fragment | ?query                 ·
  |                     · presentation_definition(_uri)      ·
  |                         (JSON or JWT(optionally encoded) ·
  |                     · nonce                              ·
  |                     · scope (optional, mapping by wallet ·
  |                       to a certain Presentation Definition
  |                        is out-of-scope in spec           ·
  |                     · client_id                          ·
  |                     · client_id_scheme ³                 ·
  |                     · client_metadata(_uri): Opt. JSON   ·
  |                     · response_mode: Optional.           ·
  |                       `direct_post` + request_uri        ·
  |                       RECOMMENDED for x-device. ⁷        ·
  |                       def value: default for grant-type  ·
  |                        (?query | fragment )              ·
  |                        Same used for "OKs" and errors.   ·
  |                     · response_type ⁴ ⁶                  ·
  |                     · aud ⁵                              ·
  |                                                          ·
  |  ┌······················································─┘
  |  ·                                                 
  |  └·> Web Browser  ··> QR Code ··················>·· Mobile App.
  |                      (Tipically Auth.Req.URI)       ·         ·                  
  |                                                     ·         ·                  
  |  ┌··················································┴─────────┘
  |  ·                                                 
  |  └·> Mobile App.² ··> OAuth Auth.Response ⁶ ·······> OAuth Client
  |                     Form POST                      
  | 
  |  Authentication Request travels across devices (Brower -> Mobile)
  |  and the Response is "POSTED" from the destination device.
  |
  |  ¹ Verifier sends either the  Authorization Request Object or 
  |    a reference as defined in JWT-Secured Authorization Request 
  |    (JAR) [RFC9101]. !!!!
  |    Non normative Authorization Request URI (that can be displayed
  |    to the End-User either directly (as a link) or as a QR Code:
  |    
  |    https://wallet.example.com?
  |        client_id=https%3A%2F%2Fclient.example.org%2Fcb
  |        &request_uri=https%3A%2F%2Fclient.example.org%2F567545564
  |
  |  ² Wallet processes the Auth. Request against existing VCs 
  |    and confirms presentation with final user that will pick what
  |    to present. Wallet is also in charge of authenticating the 
  |    End-User (fingerprint, key-pass, ...).
  |
  |  ³ How the client id must be checked by wallet (DNS, did, ...)
  |    Depending on Scheme, the Client can also attach a JSON with
  |    its client_metadata(_uri) as defined in Sec. 4.3&2.1 of OpenID 
  |    Connect Dynamic Client Registration 1.0. 
  |
  |  ⁴ respone_type==vp_token => a successful response MUST include
  |    the vp_token param. and not SHOULD NOT return an OAuth 2.0
  |    Authorization Code, Access Token, or Access Token Type.
  |    vp_token => signature and optional encryption.
  |    The default Response Mode for this Response Type is #fragment
  |    with `Authorization Response` parameters encoded in 
  |    #fragment added to the redirect_uri  (@Verifier)
  |    
  |  ⁵ `aud` value depends on whether recipient can be identified by
  |     the Verifier or not:
  |     Dynamic Discovery is performed => aud==issuer Claim value
  |     Static Discovery metadata used => aud==https://self-issued.me/v2 
  | 
  |  ⁶ VP Token can be returned in Authorization Response or Token Response 
  |   depending on the Response Type used.
  |   *    response_type == vp_token          => VP Token returned in Authorization Response 
  |   *    response_type == vp_token id_token => VP Token returned in Authorization Response
  |      && scope contains openid                alongside a Self-Issued ID Token 
  |   * Response Type value ==  code          => VP Token returned in Token Response
  | 
  |   When VP Token is returned, the OAuth Authen. response MUST include 
  |   the following REQUIRED parameters:
  |   * `vp_token`: JSON Object with
  |     alt 1.   Verifiable Presentation
  |     alt 2.  [Verifiable Presentation list]  (as JSON Array)
  |   * `presentation_submission`: mappings between requested VCs and where to
  |      find them in returned VP Token.<br/>
  |      (See original doc for details)
  |      Other presentation_submission inside the VP Token must be ignored by
  |       Clients, since it must be processed in advance to the VP Token.
  |
  |  ⁷ `response_mode=direct_post`. New in spec. POST to URL@Verifiers
  |    `response_mode=direct_post.jwt` => User jARM in Response 
  direct_post.
  |    It also fix issues with big vp_tokens.
  |    Authorization Response params. encoded in body using
  |    `application/x-www-form-urlencoded` content type. 
  |    The flow can ends after the POST, or continue if 
  |    if Verifier responds to POST with a redirect URI.
  |    * The new Authorization Request parameter is defined to be 
  |      used in conjunction with Response Mode direct_post:
  |      * `response_uri`: "CONDITIONAL". MUST be present in `direct_post`
  |        indicating where to POST the response.
  |      * `redirect_uri` MUST NOT be present in this case!!!
  |        Otherwise, wallets MUST return invalid_request Authorization Response error.
  |        If client_id_scheme == redirect_uri, client_id must be the response_uri
  | 
  |  ⁸ Verifier has the choice of the following mechanisms to invoke a Wallet:
  |    * Custom URL scheme as an authorization_endpoint (ex: openid4vp:// )
  |    * Domain-bound Universal Links/App link as an authorization_endpoint.
  |    * no specific authorization_endpoint.
  |    * user scanning a QR code with Authorization Request using a manually opened Wallet,
  ```
## non-normative OIDC4VP OAuth Request extension examples: 
* Ex/Alt 1: Non-JWT-Secured Authorization Request (JAR):
  ```
  GET /authz?
    response_type=vp_token
    &client_id=https%3A%2F%2Fclient.example.org%2Fcb
    &redirect_uri=https%3A%2F%2Fclient.example.org%2Fcb
    &presentation_definition=...
    &nonce=n-0S6_WzA2Mj HTTP/1.1
  ```
* Ex/Alt 2. JWT-Secured Authorization Request (JAR) + request 
  ```
  | HTTP 302
  | Location: /authz?
  |           client_id=s6BhdRkqt3
  |          &request=eyJhbG..AlMGzw HTTP/1.1
  | Host: a.b.com
  ```
* Ex/Alt 3. JWT-Secured Authorization Request (JAR) + request _uri
  ```
  | HTTP 302
  | Location: /authz?client_id=s6BhdRkqt3&
  |           request_uri=https%3A%2F%2Fa.b.com%2F... HTTP/1.1
  | Host: server.example.com
  ```
## 5.1. presentation_definition(_uri) Parameter:
  (See original doc, Sec. 5.1 for examples of presentation_definition) 


* Wallet metadata.vp_formats_supported: VC and VP formats supported by Wallet
  (SIOP Wallet do not annuence anything?).
* Verifier metadata: Section 9.1
  * Client metadata defined in Section 2 of [RFC7591] is used plus ...
  * `vp_formats`: formats supported. Wallet MUST ignore formats inside
                Presentation_definition not included in vp_formats
                See Apendix A in spec for specific values that can be returned.
  * `client_id_scheme`: mechanisms use to obtain and validate metadata
    of the Verifier beyond the scope of [RFC6749]. Defined values include: 
    * pre-registered: default behavior. Client Identifier needs to be known
      to the Wallet in advance of the Authorization Request.
    * redirect_uri: client id value == redirect_uri. Auth.Request MUST NOT be signed.
    * entity_id: Client Id is an Entity Identifier defined in OpenID Federation. 
    * did: Client Id is a DID => Request MUST be signed with Controller Key of DID.
      * NOTE: `kid` must be used to select one public key when DID-Document has N 
        valid ones.
* non-normative example of a JWT for a signed Auth.Request with 
  client_identifier_scheme == did
  ```
  | // HEADER:
  | { "typ": "oauth-authz-req+jwt", "alg": "RS256", "kid": "did:example:123#1" }
  | // BODY:
  | {
  |   "client_id": "did:example:123",
  |   "client_id_scheme": "did",
  |   "response_types": "vp_token",
  |   "redirect_uri": "https://client.example.org/callback",
  |   "nonce":"n-0S6_WzA2Mj",
  |   "presentation_definition": "...",
  |   "client_metadata": {                        <·· Do not include if dynamic registracion has been done
  |     "vp_formats": {
  |       "jwt_vp": { "alg": [ "EdDSA", "ES256K" ] },
  |       "ldp_vp": { "proof_type": [ "Ed25519Signature2018" ] }
  |     }
  |   }
  | }
  ```
  * `verifier_attestation`: allows to authenticate the Verifier against JWTs bound to
    a certain Pub.key.
  * `x509_san_dns`: Client Identifier type == DNS name. 
  * `x509_san_uri`: Client Identifier type == URI. 

## Authentication Response ("VP Token").

* non-normative example of an Authorization Response for
  `Authorization Request.Response Type == vp_token`
  ```
  | HTTP/1.1 302 Found
  | Location: https://client.example.org/cb#
  |   presentation_submission=...
  |   &vp_token=...
  ```
* See original doc for examples of VP Tokens with 1 or N VP.

* non-normative example of Authorization Response sent via HTTPS POST request 
  to the Verifier's Response Endpoint:
  ```
  | POST /post HTTP/1.1
  |   Host: client.example.org
  |   Content-Type: application/x-www-form-urlencoded
  |
  |   presentation_submission=...&
  |   vp_token=...&
  |   state=eyJhb...6-sVA
  ```
* non-normative example of response using presentation_submission and vp_token
  values.  (OAuth 2 JARM using JWT)
  ```
  | POST /post HTTP/1.1
  |   Host: client.example.org
  |   Content-Type: application/x-www-form-urlencoded
  |
  |   response=eyJra...9t2LQ
  | ┌─········─┴───────────┘ 
  | non-normative example of signed JWT payload               non-normative example of signed JWT payload
  |                                                           encrypted and not signed.
  | (before base64url encoding+signing)                        (before base64url encoding+signing)
  | {                                                         {
  |   "iss": "did:example:ebfeb1f712ebc6f1c276e12ec21",       
  |   "aud": "https://client.example.org/cb",                 
  |   "exp": 1573029723,                                      
  |   "vp_token": "eyJhb...YMetA",                              "vp_token": "eyJhb...YMetA",
  |   "presentation_submission": {                              "presentation_submission": {
  |     "definition_id": "example_jwt_vc",                        "definition_id": "example_jwt_vc",
  |     "id": "example_jwt_vc_presentation_submission",           "id": "example_jwt_vc_presentation_submission",
  |     "descriptor_map": [                                       "descriptor_map": [
  |       {                                                         {
  |         "id": "id_credential",                                    "id": "id_credential",
  |         "path": "$",                                              "path": "$",
  |         "format": "jwt_vp",                                       "format": "jwt_vp",
  |         "path_nested": {                                          "path_nested": {
  |           "path": "$.vp.verifiableCredential[0]",                   "path": "$.vp.verifiableCredential[0]",
  |           "format": "jwt_vc"                                        "format": "jwt_vc"
  |         }                                                         }
  |       }                                                         }
  |     ]                                                         ]
  |   }                                                         }
  | }                                                         }
  ```
* Non normative response to POST using the new in spec `redirect_uri` (optional) parameter:
  (if not present the flow is finished and wallet is free to change the UI at will).
  ```
  HTTP/1.1 200 OK
  Content-Type: application/json;charset=UTF-8
  Cache-Control: no-store

  {
    "redirect_uri":"https://client.example.org/cb#response_code=091535f699ea575c7937fa5f0f454aee"
  }
  ```
  * When redirect_uri is present the Wallet MUST send the User Agent to the destination.
    as to allow the Verifier to continue the interaction with the End-User.
    (It especially enables the Verifier to prevent session fixation attacks)
  

## Signed and Encrypted Responses
  (Sec 6.3 in spec)
* Auth request.respone_type == "vp_token" ||  "vp_token id_token"
* Implementations MAY use JWT OAuth 2.0 Secured Authorization Response Mode (JARM).
  (in a "symmetric" way to how JWT Authentication Request JAR can be used for requests)
* NOTE: Encrypting but not signing the Auth. Response prevents the signing key from
  being used as a correlation factor. 
* See original doc (Sec 6.3) for remarks on JWT encrypted (JWE) but not signed.
* key material used for encryption and signing SHOULD be determined using existing
  metadata mechanisms.
  To obtain Verifier's public key for the input to the key agreement to encrypt the
  Authorization Response, the Wallet MUST use jwks(_jwks_uri) claim within the
  client_metadata request parameter, or within the metadata defined in the Entity
  Configuration when [OpenID.Federation] is used, or other mechanisms.
* To sign the Authorization Response, the Wallet MUST use a private 
  key that corresponds to a public key made available in its metadata.
* See section 6.4 in spec for details on possible Error Responses codes returned by the wallet
* See section 6.5 in spec. for VP Token Validation details.
* See section   8 in spec for Wallet (Authorization Server) Metadata details.
* Section 10, Verifier Attestation JWT, especially designed to allow a
  Wallet to authenticate a Verifier in a secure and flexible manner. 
  (See original spec).
  Q: What is the relation to  client_id_scheme [[{PM.TODO}]] 
* See Sect 11 in spec for details Implementation Considerations
  * non-normative example of a set of static configuration values that
    can be used with vp_token parameter as a supported Response Type,
    bound to a custom URL scheme openid4vp:// as an Authorization Endpoint:
    ```
    | {
    |   "authorization_endpoint": "openid4vp:",
    |   "response_types_supported": [ "vp_token" ],
    |   "vp_formats_supported": {
    |     "jwt_vp_json": { "alg_values_supported": ["ES256"] },
    |     "jwt_vc_json": { "alg_values_supported": ["ES256"] }
    |   },
    |   "request_object_signing_alg_values_supported": [ "ES256" ]
    | }
    ```
   * Sect. 11.2. Support for Federations/Trust Schemes
   * 11.3. Nested Verifiable Presentations
   * 11.4. State Management
   * 11.5. Response Mode direct_post
* See 12. in spec Security Considerations details:
* See Appendix A in spec for Examples with Credentials in Various Formats
  ```
  | A.1. W3C Verifiable Credentials
  | A.1.1. VC signed as a JWT, not using JSON-LD
  | A.1.2. LDP VCs, Example Credential Presentation Request & Response
  | A.2. AnonCreds (Hyperledger Indy)
  | A.3. ISO mobile Driving License (mDL) !!!
  | A.3.1. Presentation Request
  | A.3.2. Presentation Response
  | A.4. Combining this specification with SIOPv2 [[{PM.TODO}]]
  ```
[[protocol.OpenID.OIDC4VP}]]

[[{Protocol.OAuth.JAR,cryptography.signature.jwt,cryptography.encryption.jwe]]
# OAuth (JWT)Secured Authorization Request (JAR)
* Part of the OAuth 2.0 Authorization Framework.

* https://datatracker.ietf.org/doc/rfc9101/
* https://www.rfc-editor.org/info/rfc9101.

* C&P from: https://openid.github.io/OpenID4VP/openid-4-verifiable-presentations-wg-draft.html
  * Verifier may send an Authorization Request as Request Object by
     value or by reference as defined in JWT-Secured Authorization Request 

## Context:
* Authorization request in OAuth 2.0 described in RFC 6749 utilizes
  query parameter serialization, which means that authorization request
  parameters are encoded in the URI of the request and sent through
  user agents such as web browsers.  Example: 
  ```
   GET /authorize?
    response_type=code&
    client_id=s6BhdRkqt3&state=xyz&
    &redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb 
    HTTP/1.1
   Host: server.example.com
  ```
   While it is easy to implement, it means that 
  * a) the communication through the user agents is not
       integrity protected and thus, the parameters can be tainted.
  * b) the source of the communication is not authenticated, and 
  * c) communication through the user agents can be monitored.
       Because of these weaknesses, several attacks to the protocol 
       have now been put forward.
    TLS mitigates the communication problem but TLS sessions are
   terminated in the user agent or may be terminated prematurely
   at some middlebox (such as a load balancer).

* JAR introduces the ability to send request parameters in a
  JSON Web Token (JWT) instead, which allows the request to be signed
  with JSON Web Signature (JWS) and encrypted with JSON Web Encryption
  (JWE) 
* new parameters introduced in OAuth 2.0 flows.
  * `request`: JWT whose JWT Claims-Set holds the JSON-encoded 
    OAuth 2.0 authorization request parameters.  
    * Note that, in contrast to RFC 7519 (JWT)", the elements of the
      Claims-Set are encoded OAuth request parameters, supplemented 
      with only a few of the IANA-managed JWT Claims [IANA.JWT.Claims],
      (<https://www.iana.org/assignments/jwt>), in particular:
      "iss" and "aud".
    * JWT is integrity protected and source authenticated using JWS !!!
  * `request_uri`: `request` by (Absolute URI) reference, to reduce
     the size of the transmitted request ("QR" in practice for x-device flows).
     (Section 5.2)

* Request Object MUST contain all the parameters (including extension)
  used to process the OAuth 2.0 Auth.Request except 
   `request` or `request_uri` themself.
  * JSON strings MUST be encoded using UTF-8 [RFC3629].
  * JWT Claims Set is defined in JWT [RFC7519].
    * `iss` and `aud` must be included with `aud` being the Auth.server.
  * JWT Claims Set is then signed or signed 
    resulting in a JWS-signed JWT and optionally encrypted resulting 
    in a Nested JWT.
* The client (3rd party app, SPA app, verifier in OIDC4VP) can inform 
  the authorization server of the algorithms that it supports in its
  dynamic client registration metadata [RFC7591]. [[{PM.TODO}]]
   
* A Request Object (Section 2.1) has the media type [RFC2046]
  `application/oauth-authz-req+jwt` !!!! but some existing
   deployments may be using `application/jwt`.

* Example Request Object Claim:
  ```
  (before base64url [RFC7515] encoding and signing)
  {
   "iss": "s6BhdRkqt3",
   "aud": "https://server.example.com",
   "response_type": "code id_token",
   "client_id": "s6BhdRkqt3",
   "redirect_uri": "https://client.example.org/cb",
   "scope": "openid",
   "state": "af0ifjsldkj",
   "nonce": "n-0S6_WzA2Mj",
   "max_age": 86400
  }
  After RS256 signing base64url encoding:
  ({"alg":"RS256","kid":"k2bdc"})
  eyJhbGciOiJSUzI1NiIsImtpZCI6ImsyYmRjIn0.ewogICAgImlzcyI6ICJzNkJoZF
  JrcXQzIiwKICAgICJhdWQiOiAiaHR0cHM6Ly9zZXJ2ZXIuZXhhbXBsZS5jb20iLAog
  ICAgInJlc3BvbnNlX3R5cGUiOiAiY29kZSBpZF90b2tlbiIsCiAgICAiY2xpZW50X2
  lkIjogInM2QmhkUmtxdDMiLAogICAgInJlZGlyZWN0X3VyaSI6ICJodHRwczovL2Ns
  aWVudC5leGFtcGxlLm9yZy9jYiIsCiAgICAic2NvcGUiOiAib3BlbmlkIiwKICAgIC
  JzdGF0ZSI6ICJhZjBpZmpzbGRraiIsCiAgICAibm9uY2UiOiAibi0wUzZfV3pBMk1q
  IiwKICAgICJtYXhfYWdlIjogODY0MDAKfQ.Nsxa_18VUElVaPjqW_ToI1yrEJ67BgK
  b5xsuZRVqzGkfKrOIX7BCx0biSxYGmjK9KJPctH1OC0iQJwXu5YVY-vnW0_PLJb1C2
  HG-ztVzcnKZC2gE4i0vgQcpkUOCpW3SEYXnyWnKzuKzqSb1wAZALo5f89B_p6QA6j6
  JwBSRvdVsDPdulW8lKxGTbH82czCaQ50rLAg3EYLYaCb4ik4I1zGXE4fvim9FIMs8O
  CMmzwIB5S-ujFfzwFjoyuPEV4hJnoVUmXR_W9typPf846lGwA8h9G9oNTIuX8Ft2jf
  pnZdFmLg3_wr3Wa5q3a-lfbgF3S9H_8nN3j1i7tLR_5Nz-g
  ```

  RSA public key in JWK format that can be used to validate the 
  Request Object signature in this and subsequent Request Object 
  examples:
  ```
  {
   "kty":"RSA",
   "kid":"k2bdc",
   "n":"x5RbkAZkmpRxia65qRQ1wwSMSxQUnS7gcpVTV_cdHmfmG2ltd2yabEO9XadD8
        pJNZubINPpmgHh3J1aD9WRwS05ucmFq3CfFsluLt13_7oX5yDRSKX7poXmT_5
        ko8k4NJZPMAO8fPToDTH7kHYbONSE2FYa5GZ60CUsFhSonI-dcMDJ0Ary9lxI
        w5k2z4TAdARVWcS7sD07VhlMMshrwsPHBQgTatlkxyIHXbYdtak8fqvNAwr7O
        lVEvM_Ipf5OfmdB8Sd-wjzaBsyP4VhJKoi_qdgSzpC694XZeYPq45Sw-q51iF
        UlcOlTCI7z6jltUtnR6ySn6XDGFnzH5Fe5ypw",
   "e":"AQAB"
  }
  ```

* Authorization Request:
  client (App, verifier,...) constructs the Authorization Request
  URI by adding the following parameters to the query component of
  the authorization endpoint URI using the 
  `application/x-www-form-urlencoded` format:
  * `request`
  * `request_uri`
  * `client_id`. It must match that in `request(_uri)`. 

  * client directs the resource owner to the constructed URI using an
    HTTP redirection response or by other means available to it via the
    user agent. !!!! Example:
    ```
    HTTP 302
    Location: /authz?client_id=s6BhdRkqt3&request=eyJhbG..AlMGzw HTTP/1.1
    Host: a.b.com


    HTTP 302
    Location: /authz?client_id=s6BhdRkqt3&
                    request_uri=https%3A%2F%2Fa.b.com%2Frequest.jwt%2FGkur... HTTP/1.1
    Host: server.example.com

    ```
  * client MAY send the parameters included in the Request Object
    duplicated in the query parameters for backward compatibility,
    but Auth. Server must ignore them. 

* Signature Algorithm verification MUST be performed by recipients
  (Auth. SERvers or SIOP Wallets) as specified in Sections 3.1 and 3.2 of [RFC8725].
  * On failure, they must respond with `invalid_request_object` 

* Authorization Server Response (Wallet in SIOP)
  * All those in Section 4 of [RFC6749] (OAuth 2.0).
  * invalid_request_uri
  * invalid_request_object
  * request_not_supported
  * request_uri_not_supported

* Client implementations supporting the Request Object URI method MUST
  support TLS.
* HTTP clients MUST also verify the TLS server certificate, using DNS-
  ID [RFC6125], to avoid man-in-the-middle attacks. 
*  Support for DNS-ID identifier type (that is, the dNSName identity
   in the subjectAltName extension) is REQUIRED. 

##  IANA Considerations
* Since the Request Object is a JWT, the core JWT claims cannot be used
  for any purpose in the Request Object other than for what JWT
  dictates. Thus, they have been registered as OAuth authorization
  request parameters to avoid future OAuth extensions using them with
  different meanings.
* OAuth Authorization Server Metadata Registry
  * Spec add new "require_signed_request_object"
    indicating where authorization request needs to
    be protected as Request Object and provided through 
    either "request" or "request_uri parameter".
* OAuth Dynamic Client Registration Metadata Registry
  * Specs add new  "require_signed_request_object" 
    indicating where authorization request needs to
    be protected as Request Object and provided 
    through either "request" or "request_uri parameter".

* See original source, section 10 for Security Considerations.
* See original source, section 11 for Privacy Considerations
[[Protocol.OAuth.JAR}]]

# OAuth (JWT)Secured Authorization Response Mode  (JARM) [[{Protocol.OAuth.JARM]]
* REF: <https://openid.net/specs/oauth-v2-jarm.html>

* JWT-based mode to encode OAuth authorization responses
  enhancing the security with support for signing and optional
  encryption.
* JWT always contains:
  * `iss`: issuer 
  * `aud`: OAuth client_id this response is intended for.
  * `exp`: expiration of the JWT. (10 min max is RECOMMENDED).
  * authorization endpoint response parameters as defined for
    the particular response types.
    * For example Response for grant type authorization "code" 
      requires the extra `code` and `state` claims.
  * Error response params if appropiate:
    error (code), error_description and  error_uri. 
* Signing + encrypting results in a nested JWT.

* Response Modes:
  * Response Mode "query.jwt" example:
    ```
    HTTP/1.1 302 Found
    Location: https://client.example.com/cb?response=eyJra... JWT token ...
    ```
    * WARN: "query.jwt" response mode MUST NOT be used in conjunction 
      with response types that contain "token" or "id_token" unless
      the response JWT is encrypted to prevent token leakage in the URL.
  * Response Mode "query.jwt" example:
    ```
    HTTP/1.1 302 Found
    Location: https://client.example.com/cb#response=eyJra... JWT token ...
    ```
  * Response Mode "form_post.jwt" example:
    ```
    | HTTP/1.1 200 OK
    | Content-Type: text/html;charset=UTF-8
    | Cache-Control: no-cache, no-store
    | Pragma: no-cache
    | 
    | <html>
    |  <head><title>Submit This Form</title></head>
    |  <body onload="javascript:document.forms[0].submit()">
    |   <form method="post" action="https://client.example.com/cb">
    |     <input type="hidden" name="response"
    |      value="eyJraW ... JWT token ... " />
    |     </form>
    |    </body>
    |   </html>
    | <!-- form auto-submitted in the User Agent in
    |      "application/x-www-form-urlencoded" format like:
    |      POST /cb HTTP/1.1
    |      Host: client.example.org
    |      Content-Type: application/x-www-form-urlencoded
    |      
    |      response=eyJraW JWT Token ...
    ```

* Response Mode "jwt" defaults to redirect default encoding:
  query.jwt for `code` and fragment.jwt for `token` and response types
  defined in "OAuth 2.0 Multiple Response Type Encoding Practices""
  
## Processing rules
* client decrypts the JWT using the default key for the respective issuer or,
  if applicable, determined by the kid JWT header parameter. 
* The key might be a private key, where the corresponding public key is
  registered with the expected issuer of the response.
* check iss: well known, identifies the expected issuer.
* check aud matches client id
* checks exp 
* check signature. 
* check CSRF detection ... (out of scope of this specification).
* The following client metadata parameters in the Dynamic Client
  Registration Protocol are introduced by this specification:
  * `authorization_signed_response_alg`: REQUIRED
  * `authorization_encrypted_response_alg`: REQUIRED
  * `authorization_encrypted_response_enc`: REQUIRED
  NOTE: `jwks_uri` or `jwks metadata` parameters can be used by
     clients to register their public encryption keys.

* Authorization Server Metadata:
  (Check original doc for more info) 
  new params are included:
  * `authorization_signing_alg_values_supported`    OPTIONAL
  * `authorization_encryption_alg_values_supported` OPTIONAL
  * `authorization_encryption_enc_values_supported` OPTIONAL

* See original doc for details on Security Considerations
[[Protocol.OAuth.JARM}]]

# FAPI Related Tecnologies [[{FAPI,PM.TODO]]
<https://medium.com/@hidebike712/fapi2-explained-8602e52596e5>
[[FAPI}]]

# TODO/Non-Classified [[{PM.TODO.now]]
* OAuth 2.0 Bearer Token Usage [RFC6750]
* <https://openid.net/specs/openid-connect-core-1_0.html> @ma
* OpenID Connect Discovery 1.0 [OpenID.Discovery]
* OpenID Connect Dynamic Client Registration 1.0
  <https://openid.net/specs/openid-connect-registration-1_0.html>
* Dynamic Client Registration Protocol [RFC7591] defines an API  
  for dynamically registering OAuth 2.0 client metadata with
  authorization servers. [[{PM.TODO.now}]]

* https://openid.net/sg/openid4vc/specifications/
* https://openid.github.io/OpenID4VCI/openid-4-verifiable-credential-issuance-wg-draft.html
* https://openid.github.io/OpenID4VP/

* OAuth 2.0 Threat Model and Security Considerations
  <https://tools.ietf.org/html/rfc6819>

OThers:
* @[https://oauth.net/2/]
[[}]]
